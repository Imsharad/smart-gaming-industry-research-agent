Architecting Autonomous Systems: A Comprehensive Technical Report on the Claude Agent SDK, In-Process MCP Integration, and Hierarchical Sub-Agent Patterns1. Introduction: The Evolution of Agentic ArchitecturesThe trajectory of artificial intelligence has shifted precipitously from static request-response models to dynamic, autonomous agentic systems. This transition represents a fundamental reimagining of how software interacts with the world. Where Large Language Models (LLMs) once served as passive engines of text generation, they now function as the cognitive cores of sophisticated agents capable of perceiving environments, formulating plans, executing actions, and maintaining persistent state.This report provides an exhaustive technical analysis of the Claude Agent SDK for Python, a framework engineered by Anthropic to facilitate the creation of such agents. Unlike traditional chatbot interfaces, this SDK is designed to orchestrate complex, multi-step workflows by granting the underlying model—Claude—direct access to computational tools, local file systems, and command-line interfaces.1 The analysis that follows will dissect the three critical pillars of modern agentic design within this ecosystem: the orchestration runtime provided by the SDK, the seamless integration of tools via In-Process Model Context Protocol (MCP) servers, and the implementation of hierarchical delegation through Sub-Agents and the Skills.md knowledge specification.We are observing a move away from monolithic prompt engineering towards "System Engineering" for AI. In this new paradigm, the prompt is merely one component of a larger cognitive architecture that includes memory management, tool interfaces, and permission systems. The Claude Agent SDK embodies this shift, wrapping the powerful Claude Code CLI in a Pythonic interface that allows developers to build robust, production-grade applications.2 By understanding the nuances of this SDK, systems architects can construct agents that do not simply "talk" but actively "work"—reading files, fixing bugs, conducting research, and managing infrastructure with a level of autonomy previously unattainable.12. The Claude Agent SDK ArchitectureThe foundation of any agentic system is its runtime environment—the "body" that houses the AI "brain." The Claude Agent SDK (Python) serves this function, acting not merely as a wrapper for API calls but as a sophisticated orchestration layer. It manages the lifecycle of the agent, handles the bidirectional stream of information between the user and the model, and enforces the boundaries of what the agent is permitted to do.2.1 Core Design Philosophy and The Async-First RuntimeThe SDK is built upon an async-first architecture, leveraging the anyio library to ensuring broad compatibility with Python's asynchronous ecosystems, including both asyncio and trio.2 This architectural decision is non-trivial. In high-performance agentic workflows, the agent is frequently I/O bound—waiting for a file to be read, a shell command to execute, or a web search to return results. A blocking, synchronous architecture would leave the application unresponsive during these intervals. By adopting an async-first approach, the Claude Agent SDK allows the main application thread to remain responsive, enabling high-concurrency environments where multiple agents or sub-agents can operate in parallel without locking the system resources.The SDK exposes two primary modes of interaction, each catering to a distinct class of architectural requirements:Stateless Execution (query()):The query() function represents the simplest entry point into the SDK. It is designed for "fire-and-forget" or single-turn tasks where long-term state maintenance is unnecessary. When invoked, query() initializes a transient agent instance, passes the user's prompt, orchestrates the execution, and tears down the context immediately upon completion.1 This mode is particularly advantageous for automation pipelines—such as a CI/CD job that asks Claude to "Summarize the changes in this commit" or "Check this file for syntax errors." The overhead of session management is bypassed, optimizing for speed and resource reclamation.4Stateful Orchestration (ClaudeSDKClient):For complex, multi-turn workflows—the hallmark of true agentic behavior—the ClaudeSDKClient class is essential. This class creates a persistent connection to the underlying Claude Code process, maintaining a continuous session_id. This persistence allows the agent to "remember" the results of previous tool executions, user corrections, and intermediate reasoning steps across multiple turns of conversation.3 The ClaudeSDKClient implements the Python Context Manager protocol (async with), ensuring that the underlying subprocesses and connection pools are managed safely and cleaned up deterministically.3Table 1: Comparative Analysis of SDK Interaction ModesFeaturequery() FunctionClaudeSDKClient ClassState PersistenceTransient (Single Turn)Persistent (Multi-Turn Session)Connection LifecycleOpened and Closed per callLong-lived Task GroupUse CaseAutomation, One-off tasks, CI/CDInteractive Assistants, Complex WorkflowsResource ManagementAutomatic CleanupManual/Context Manager (async with)Interruption SupportLimitedNative interrupt() method supportSession IDAuto-generated/DisposablePersistent/Resumeable2.2 The Agent Loop and Context ManagementA critical challenge in the design of Large Language Model agents is Context Window Management. As an agent operates—reading large code files, receiving verbose error logs from shell commands, and engaging in internal reasoning monologues—the volume of text in the context window accumulates rapidly. If left unchecked, this accumulation leads to two failure modes: context exhaustion (hitting the hard token limit of the model) or performance degradation (the "lost in the middle" phenomenon where the model struggles to retrieve information from a saturated context).The Claude Agent SDK addresses this through a mechanism known as Context Compaction. By wrapping the Claude Code CLI, the SDK inherits its advanced context management strategies. When the conversation history exceeds a defined threshold, the system automatically summarizes older turns or compresses verbose tool outputs, retaining the salient information required for decision-making while freeing up tokens for new reasoning.5 This process is largely opaque to the developer, functioning as a managed service within the runtime, but it is essential for the viability of long-running agents that might operate for hours or days.The operational lifecycle of a ClaudeSDKClient session follows a rigorous state machine:Initialization: The client is instantiated with ClaudeAgentOptions, defining the agent's boundaries (e.g., allowed tools, working directory).Connection: The connect() method spawns the underlying CLI subprocess, establishing the communication pipes.The Interaction Loop:Prompting: The user sends a message via client.query().Reasoning: Claude analyzes the prompt and the current context.Tool Selection: If action is required, Claude selects a tool (e.g., Read, Bash, or a custom MCP tool).Execution: The SDK intercepts this request. If it is a client-side tool (In-Process MCP), the SDK executes it directly. If it is a CLI-native tool, the command is passed to the subprocess.Feedback: The result of the tool execution is fed back into the context.Iteration: The loop repeats until Claude determines the task is complete.6Termination: The disconnect() method ensures a graceful shutdown.2.3 Configuration and ClaudeAgentOptionsThe ClaudeAgentOptions data structure is the control panel for the agent's environment. It allows the systems architect to define the "physics" of the world the agent inhabits—what it can touch, where it can go, and who it needs to ask for permission.Key Configuration Parameters:allowed_tools: This is the primary security boundary. It is a whitelist of strings defining exactly which capabilities are exposed to the model. Common values include "Read", "Write", "Bash", "Grep", and custom namespaced tools like "mcp__my-server__my-tool".1 Excluding "Bash" from this list, for example, creates a safer, read-only agent that cannot execute arbitrary system commands.permission_mode: This parameter governs the agent's autonomy."ask" (default): The agent must request explicit human approval for every tool execution. This is the "Human-in-the-Loop" standard."acceptEdits": The agent is authorized to modify files without confirmation but may still prompt for shell commands."bypassPermissions": The agent has full autonomy to execute any allowed tool. This mode is necessary for fully autonomous background agents but carries significant risk.9system_prompt: This defines the persona and operational constraints. It can be a custom string or a preset configuration like claude_code.12cwd (Current Working Directory): This parameter defines the agent's "scope of awareness." It determines where the agent looks for files and, crucially, where it looks for project-specific configuration files like CLAUDE.md and .claude/skills.5The careful configuration of ClaudeAgentOptions is what differentiates a generic chatbot from a specialized tool. By restricting allowed_tools and setting a specific cwd, a developer can create an agent that is practically omnipotent within a single project folder but utterly powerless to affect the rest of the system—a principle known as Scoped Autonomy.3. Model Context Protocol (MCP): The In-Process ParadigmThe Model Context Protocol (MCP) represents the standardized interface by which Anthropic agents connect to external data and logic. It decouples the definition of a tool from its execution, allowing agents to interface with everything from local databases to remote APIs. While the standard MCP architecture typically employs a client-host model over stdio or HTTP (where the tool runs in a completely separate process), the Claude Agent SDK introduces a powerful optimization: the In-Process MCP Server.43.1 limitations of External MCP ServersTo appreciate the value of the In-Process model, one must first understand the constraints of the standard external approach. in a typical MCP setup, the agent spawns a subprocess—perhaps a Node.js script to access a filesystem or a Python script to query a database. Communication occurs via JSON-RPC messages piped over standard input and output.While this architecture offers excellent modularity and fault isolation, it introduces significant friction for complex application integration:Serialization Overhead: Every piece of data exchanged between the agent and the tool must be serialized to JSON, transmitted across the process boundary, parsed, processed, and then serialized back. For heavy payloads—such as large pandas DataFrames or binary data—this serialization cost is non-trivial and induces latency.State Isolation: The external tool process is memory-isolated from the main application. It cannot access shared in-memory objects, such as an initialized database connection pool, a loaded machine learning model, or the user's active session state. To share this data, the developer must implement complex workarounds, such as writing state to a temporary file or setting up a local socket server.4Debugging Complexity: Debugging a tool requires attaching a debugger to a transient subprocess, complicating the development feedback loop.3.2 The In-Process AdvantageThe In-Process SDK MCP Server flips this paradigm. facilitated by the create_sdk_mcp_server function, these servers run strictly within the same Python process and the same event loop as the main ClaudeSDKClient.Advantages of In-Process Execution:Zero Subprocess Overhead: Tool calls are executed as direct Python function invocations. There is no inter-process communication (IPC), no pipe management, and minimal serialization overhead.Shared State Access: Because the tool runs in the same memory space, it can access global variables, singleton instances, or state objects passed during initialization. A tool can effectively "reach out" and manipulate the application's runtime state directly.Rich Type Integration: While the LLM still receives text, the internal logic of the tool can work with complex Python objects. The tool can accept a string from Claude, use it to query a dataframe held in memory, and return a summary, all without that dataframe ever leaving the process RAM.Simplified Deployment: The entire agent, including its custom tools, can be packaged as a single Python application without the need to manage a fleet of sidecar processes.4Table 2: Transport Protocol Comparison for MCPFeatureStdio (External)HTTP/SSE (Remote)In-Process (SDK)Execution EnvironmentSeparate SubprocessRemote ServerSame ProcessCommunicationJSON-RPC over StdioJSON over HTTPDirect Function CallLatencyMedium (IPC Overhead)High (Network Overhead)Low (Zero Overhead)State AccessIsolatedIsolatedShared/DirectComplexityMediumHighLowBest Use CaseGeneric Utilities (e.g., git, filesystem)Enterprise MicroservicesApplication-Specific Business Logic3.3 Implementation Strategy: Building a Custom ToolTo implement an in-process server, the developer utilizes the claude_agent_sdk decorators to define tools and the registration functions to bundle them.Step 1: Defining the Tool LogicTools are defined as standard Python functions. The @tool decorator is used to attach the necessary metadata—the name, description, and argument schema—that the LLM needs to understand how to use the tool.Pythonfrom claude_agent_sdk import tool

# Global application state (simulated)
APP_STATE = {
    "user_id": 101,
    "active_orders":
}

@tool(
    name="get_order_details", 
    description="Retrieves full details for a specific order ID from the in-memory cache.",
    args_schema={"order_id": str}
)
async def get_order_details(args: dict) -> dict:
    """
    Directly accesses global APP_STATE without IO overhead.
    """
    order_id = args["order_id"]
    
    # Simulate lookup
    if order_id in APP_STATE["active_orders"]:
        # Logic to fetch complex object
        return {
            "content":
        }
    else:
        return {
            "content": [
                {"type": "text", "text": f"Error: Order {order_id} not found."}
            ]
        }
Step 2: Creating the Server WrapperThe create_sdk_mcp_server function aggregates these individual tool functions into a server object that adheres to the MCP specification.Pythonfrom claude_agent_sdk import create_sdk_mcp_server

# Creates a lightweight server wrapper around the functions
order_server = create_sdk_mcp_server(
    name="order-system",
    version="1.0.0",
    tools=[get_order_details]
)
Step 3: Registration and NamespacingThe server object is then passed into ClaudeAgentOptions. A critical implementation detail here is Namespacing. To prevent naming collisions between different servers (e.g., two servers both having a status tool), the SDK automatically prefixes tool names. The pattern is mcp__{server_name}__{tool_name}.The developer must explicitly add this namespaced string to the allowed_tools list. Failing to do so is a common configuration error that results in the tool being hidden from the model.10Pythonoptions = ClaudeAgentOptions(
    mcp_servers={"orders": order_server},
    # Note the double underscores in the naming convention
    allowed_tools=
)
3.4 Advanced Pattern: Hybrid Server ArchitectureThe SDK's flexibility allows for a Hybrid Architecture where In-Process servers and External Stdio servers coexist. This is particularly powerful for building "Super-Agents" that need both domain-specific business logic and generic capabilities.Internal Server: Handles application-specific logic (e.g., "Restart the simulation," "Update the user's profile"). These benefit from shared state.External Server: Handles generic utilities (e.g., the filesystem MCP server provided by Anthropic, or a git MCP server). These benefit from being off-the-shelf, pre-tested binaries that run in isolation.8This hybrid approach allows architects to compose agents from a library of standard tools while injecting highly specific proprietary logic directly into the agent's brain via the In-Process interface.4. Hierarchical Delegation: Sub-Agents and The "Task" ToolAs the scope of an agent's responsibility grows, a single system prompt becomes insufficient. A prompt that attempts to define the rules for coding, testing, deployment, database management, and documentation simultaneously becomes bloated and contradictory. This leads to "context drift," where the agent confuses instructions from one domain with another.The architectural solution to this problem is Hierarchical Delegation. The Claude Agent SDK implements this pattern via Sub-Agents, allowing a main "Orchestrator" agent to delegate specific units of work to specialized "Worker" agents.144.1 The Theory of Agent SpecializationA Sub-Agent is a distinct instantiation of the Claude model, characterized by three isolating factors:Restricted Scope: It possesses a narrower, highly focused System Prompt (e.g., "You are a Security Auditor. You only look for vulnerabilities; you do not write new features.").Specialized Tools: It is granted access to only the subset of tools relevant to its domain. A "Researcher" agent might have WebSearch and Read but explicitly lack Write or Bash, making it physically impossible for it to alter the system state.9Context Isolation: The sub-agent operates in a fresh, empty context window. It does not see the main agent's conversation history, nor does the main agent see the sub-agent's internal chain of thought. This "Context Hiding" is crucial for efficiency; it prevents the main agent's context from being polluted by the verbose intermediate steps of the sub-tasks.144.2 Programmatic Definition via AgentDefinitionThe SDK enables the definition of these agents directly in Python code using the AgentDefinition class. This programmatic approach is preferred over filesystem configuration for dynamic applications as it keeps the agent logic coupled with the application code.Pythonfrom claude_agent_sdk import AgentDefinition

# Define a specialist agent
security_agent = AgentDefinition(
    description="A strict security reviewer. Use this for all code audits and vulnerability scans.",
    prompt="""
    You are a Security Auditor. 
    Review the provided code for OWASP Top 10 vulnerabilities.
    Be extremely critical.
    Output only the list of vulnerabilities found.
    """,
    tools=,
    model="claude-3-5-sonnet-20241022"  # Explicit model selection for high capability
)
This definition is then passed to the main agent's options:Pythonoptions = ClaudeAgentOptions(
    agents={"sec_auditor": security_agent},
    # The "Task" tool is the mechanism for delegation
    allowed_tools= 
)
4.3 The "Task" Tool MechanismThe integration point for sub-agents is the "Task" tool. This tool acts as the bridge between the parent and the child. When the main agent recognizes a user request that matches a sub-agent's description, it formulates a call to the Task tool.3The Delegation Workflow:Trigger: The user asks the Main Agent: "Write a function to connect to the DB, then audit it for security."Execution: The Main Agent writes the code using its own tools.Routing: The Main Agent analyzes the second part of the request ("audit it for security"). It scans its list of available sub-agents and identifies that the sec_auditor agent (described as "A strict security reviewer") is the correct match.Invocation: The Main Agent calls the tool: Task(agent="sec_auditor", prompt="Audit the file database.py for vulnerabilities").Context Switch (SDK Runtime):The SDK pauses the Main Agent's execution loop.It initializes the sec_auditor Sub-Agent with a fresh context.It injects the passed prompt as the first user message to the Sub-Agent.The Sub-Agent runs its own autonomous loop, using its specialized tools (Grep, mcp__security__scan).The Sub-Agent concludes and produces a final textual response.Return: The SDK captures this response and returns it as the result of the Task tool call to the Main Agent.Synthesis: The Main Agent reads the audit report and presents it to the user.Insight: This pattern allows for Recursive Capability without Recursive Complexity. The Main Agent does not need to know how to use the security scanning tools; it only needs to know who can use them.Constraint Warning: It is explicitly noted in the documentation that sub-agents cannot spawn their own sub-agents to avoid infinite recursion loops (Task should not be in a sub-agent's tool list). Furthermore, only the Task tool allows this delegation; standard tool calls are strictly local to the active agent.145. Skills.md: The Modular Knowledge ProtocolWhile AgentDefinition handles the runtime behavior (actions and tools), Skills.md handles the instructional context (knowledge and procedures). It is Anthropic's specification for the "Progressive Disclosure" of capabilities, designed to solve the problem of System Prompt limits.165.1 The Progressive Disclosure PhilosophyIn a complex domain, an agent might need to know thousands of pages of documentation—API references, coding standards, compliance guidelines, and architectural patterns. stuffing all this into the System Prompt is impossible due to token limits and cost.Progressive Disclosure solves this by layering information:Metadata Layer (Low Cost): The agent is given a list of summaries of what knowledge is available.Activation Layer (On-Demand): Only when the agent determines it needs specific knowledge does it "load" the full detailed instructions.5.2 The Skills SpecificationA "Skill" in the Anthropic ecosystem is physically structured as a directory containing a markdown file (conventionally SKILL.md) and potentially other supporting resources.The core file structure leverages YAML Frontmatter to provide the metadata layer:name: "fastapi-expert"
description: "Best practices, architectural patterns, and security guidelines for building FastAPI applications."FastAPI Development Guide(Detailed instructions, code snippets, and architectural patterns follow here...)The Mechanism of Action:Discovery: When the agent starts up (specifically when the CLI underlying the SDK initializes), it scans the designated skills directory (e.g., .claude/skills or .github/skills).Prompt Injection (Phase 1): It reads only the YAML frontmatter (name and description). It appends a concise list of these available skills to the agent's System Prompt.Result: The agent knows that it can be a "FastAPI Expert," but it hasn't loaded the text yet.Trigger: If the user asks, "How do I structure a router in FastAPI?", the agent recognizes the relevance of the "fastapi-expert" skill from its description.Loading (Phase 2): The agent executes an internal command to load the full content of the Markdown file into its active context window.Result: The agent now has the deep knowledge required to answer the question, but this token cost is only incurred at the moment of need.185.3 SDK Integration and Custom LoadersThe research indicates that native skills.md support is primarily a feature of the Claude Code CLI that the SDK wraps.20 When using the Python SDK, ensuring that the cwd option in ClaudeAgentOptions points to a project root containing a .claude/skills directory allows the underlying CLI process to detect and use these skills automatically.However, for developers requiring more control—for instance, loading skills from a database or a remote CMS rather than local files—the In-Process MCP architecture provides a perfect mechanism to emulate this. A developer can build a custom "Skill Loader" tool:Python@tool("load_skill", "Loads detailed instructions for a specific domain")
def load_skill(skill_name: str):
    # Custom logic to fetch skill content
    # This emulates the CLI's native behavior but gives the Python dev full control
    return database.fetch_skill_content(skill_name)
This approach manually implements the Progressive Disclosure pattern using standard MCP tools, decoupling the agent's knowledge base from the local filesystem.19Table 3: Sub-Agents vs. SkillsFeatureSub-AgentsSkillsPrimary FunctionExecution (Doing things)Knowledge (Knowing things)ContextIsolated (New Context Window)Shared (Loaded into Current Context)Tool AccessSpecialized/RestrictedSame as Parent AgentUse CaseRisk isolation, Task delegationDocumentation, Coding Standards, SOPsMechanismTask toolImplicit loading / Prompt injection6. Comprehensive Implementation StrategyThis section synthesizes the SDK, In-Process MCP, Sub-Agents, and Skills into a coherent system architecture. We will define a "Software Factory" system comprising a Manager Agent (Orchestrator) and two specialists (Coder and Researcher).6.1 System ArchitectureOrchestrator (Main Agent):Role: Project Manager.Tools: Task, Bash, Read.Skills: "Agile Management" (loaded from skills.md).Sub-Agent A (Coder):Role: Implementation Specialist.Tools: Edit, Bash, Grep, mcp__linter__validate.MCP: In-Process Linter Server.Sub-Agent B (Researcher):Role: Information Gatherer.Tools: Read, Bash (restricted).MCP: In-Process Knowledge Base Query Tool.6.2 Step-by-Step ImplementationA. Defining the In-Process MCP ServersFirst, we create the specialized tools for the sub-agents. This tool allows the Coder agent to validate its own code before finishing.Python# tools/linter_tools.py
from claude_agent_sdk import tool, create_sdk_mcp_server

@tool("validate_syntax", "Checks python syntax")
async def validate_syntax(args: dict) -> dict:
    code = args.get("code", "")
    try:
        compile(code, "<string>", "exec")
        return {"content":}
    except SyntaxError as e:
        return {"content":}

# Create the server object
linter_server = create_sdk_mcp_server("linter", tools=[validate_syntax])
B. Defining the Sub-AgentsWe use AgentDefinition to configure the specialists. Note the explicit tool lists.Python# agents/definitions.py
from claude_agent_sdk import AgentDefinition

coder_agent = AgentDefinition(
    description="Expert Python Developer. Writes and fixes code.",
    prompt="You are a senior python engineer. Write clean, typed code. Validate syntax before finishing.",
    tools=,
    model="claude-3-5-sonnet-20241022"
)

researcher_agent = AgentDefinition(
    description="Technical Researcher. Finds libraries and docs.",
    prompt="You are a researcher. Summarize documentation. Do not write code.",
    tools=, 
    model="claude-3-haiku-20240307" # Lower cost model for research
)
C. Configuring the Main LoopWe bind everything into the ClaudeSDKClient.Python# main.py
import asyncio
from claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions
from tools.linter_tools import linter_server
from agents.definitions import coder_agent, researcher_agent

async def main():
    # Configure the Orchestrator
    options = ClaudeAgentOptions(
        system_prompt="You are a Software Factory Manager. Delegate tasks to your specialists.",
        
        # Register Sub-Agents
        agents={
            "coder": coder_agent,
            "researcher": researcher_agent
        },
        
        # Register In-Process MCP (Global Scope)
        # Note: Even though registered globally, only agents with the 
        # namespaced tool in their 'tools' list can access it.
        mcp_servers={
            "linter": linter_server
        },
        
        # Tools allowed for the MAIN agent (Orchestrator)
        allowed_tools=,
        
        # Point to a directory with.claude/skills for implicit skill support
        cwd="./my_software_factory_workspace",
        
        permission_mode="acceptEdits" # High Autonomy
    )

    async with ClaudeSDKClient(options=options) as client:
        # Initial Trigger
        prompt = "Research the best way to use FastAPI with SQLAlchemy, then write a basic app."
        
        # The Orchestrator will:
        # 1. Call Task(agent="researcher", prompt="Research FastAPI+SQLAlchemy...")
        # 2. Receive report.
        # 3. Call Task(agent="coder", prompt="Write app based on this report...")
        # 4. Coder will use mcp__linter__validate_syntax during its work.
        
        await client.query(prompt)
        
        # Stream the response (including sub-agent activity summaries)
        async for message in client.receive_response():
            # In a real app, you would parse message.content here
            print(message)

if __name__ == "__main__":
    asyncio.run(main())
6.3 Debugging and ObservabilityWhen running such a complex stack, visibility is paramount. The SDK operates asynchronously, and exceptions in sub-agents or MCP tools can sometimes be swallowed if not handled correctly.Logging: The SDK outputs raw messages. Parsing the ToolUseBlock is essential to see which agent is acting.Sub-Agent Visibility: When a sub-agent is running, the main agent is effectively "blocked" waiting for the Task tool result. However, the SDK streams the sub-agent's activity to stdout (or the configured handler), allowing real-time monitoring of the delegation.1Error Propagation: If the coder agent fails (e.g., Python exception in the in-process tool), the error is returned as a ToolResultBlock with is_error=True. The sub-agent sees this and can retry. If the sub-agent fails completely, the Task tool returns an error to the Orchestrator, allowing the Manager to decide on a course of action (e.g., "Try again with different instructions" or "Report failure to user").107. Security and Best Practices7.1 Security Considerations of In-Process ToolsIn-process MCP servers run with the same privileges as the host application. This is a double-edged sword. While it enables powerful integration, a vulnerability in an MCP tool (e.g., a SQL injection flaw in a database query tool) exposes the entire application's memory and state.Mitigation: Strict input validation must be applied within the @tool function.Permission Mode: For sensitive tools, use permission_mode="ask". This forces the agent to ask the human user for confirmation before executing the tool, adding a critical safety layer.97.2 Token Efficiency and CostThe "In-Process + Sub-Agent + Skills" architecture is powerful but token-heavy.Skills: Use them to prevent loading massive library documentation into the system prompt until absolutely needed.Sub-Agents: They prevent Context Pollution. A 50-turn debugging session with a Coder agent generates a massive amount of tokens. If this were all in one main context, it would degrade performance. By using a sub-agent, the Manager only sees the summary of the result (e.g., "Bug fixed in main.py"), keeping the high-level context clean and efficient.147.3 Managing State in Long-Running ProcessesFor agents intended to run for days or weeks (e.g., a "DevOps Monitor"), reliant on the ClaudeSDKClient's persistent session is insufficient if the script crashes.Persistence: The current SDK supports session resumption via session_id. It is Best Practice to serialize this session_id to a database or file. Upon restarting the application, the ClaudeSDKClient can be re-initialized with this ID to resume the conversation context exactly where it left off.8. ConclusionThe Claude Agent SDK for Python provides the necessary primitives to move beyond prompt engineering into System Engineering. By combining In-Process MCP Servers for deep system integration, Sub-Agents for cognitive load balancing, and Skills.md for modular knowledge management, developers can architect AI systems that are not just chat interfaces, but resilient, autonomous operators capable of meaningful work.The code structures defined in this report—specifically the use of AgentDefinition for hierarchy and create_sdk_mcp_server for tooling—represent the blueprint for the next generation of intelligent software automation. As these agents become more capable, the role of the developer shifts from writing the code that does the work, to writing the code that defines the agent that does the work.(End of Report)