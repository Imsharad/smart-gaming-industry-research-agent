START OF FILE: energy-advisor/my_submission/master_context.md
================================================================================

# Master Context for energy-advisor
Generated on Fri Dec 19 15:18:53 IST 2025


<file_content path="01_db_setup.ipynb">
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EcoHome Energy Advisor - Database Setup\n",
    "\n",
    "In this notebook, you'll set up the database for the EcoHome Energy Advisor. The database will store:\n",
    "- Energy usage data (consumption, device types, costs)\n",
    "- Solar generation data (production, weather conditions)\n",
    "\n",
    "## Learning Objectives\n",
    "- Create SQLite database with proper schema\n",
    "- Populate database with sample data\n",
    "- Query data for analysis\n",
    "- Understand database design for energy management\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Import Required Libraries\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[33mWARNING: The candidate selected for download or install is a yanked version: 'pydantic' candidate (version 2.12.1 at https://files.pythonhosted.org/packages/f5/69/ce4e60e5e67aa0c339a5dc3391a02b4036545efb6308c54dc4aa9425386f/pydantic-2.12.1-py3-none-any.whl (from https://pypi.org/simple/pydantic/) (requires-python:>=3.9))\n",
      "Reason for being yanked: references a yanked version of pydantic-core\u001b[0m\u001b[33m\n",
      "\u001b[0m\u001b[33mWARNING: The candidate selected for download or install is a yanked version: 'pydantic-core' candidate (version 2.41.3 at https://files.pythonhosted.org/packages/43/05/362832ea8b890f5821ada95cd72a0da1b2466f88f6ac1a47cf1350136722/pydantic_core-2.41.3-cp311-cp311-macosx_11_0_arm64.whl (from https://pypi.org/simple/pydantic-core/) (requires-python:>=3.9))\n",
      "Reason for being yanked: corrupted wheel got uploaded\u001b[0m\u001b[33m\n",
      "\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m24.3.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.2\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpython3.11 -m pip install --upgrade pip\u001b[0m\n",
      "Note: you may need to restart the kernel to use updated packages.\n"
     ]
    }
   ],
   "source": [
    "%pip install -q sqlalchemy==2.0.23 langchain==0.3.25 langchain-core==0.3.76 langchain-openai==0.3.6 langchain-community==0.3.24 langchain-chroma==0.2.6 langgraph==0.2.76 numpy==1.26.4 pydantic==2.12.1 chromadb==1.1.1 openai==1.58.1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import the necessary libraries\n",
    "from datetime import datetime, timedelta\n",
    "import random\n",
    "\n",
    "from models.energy import DatabaseManager"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Initialize Database Manager\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a DatabaseManager instance\n",
    "# Initialize it with the path \"data/energy_data.db\"\n",
    "db_manager = DatabaseManager(\"data/energy_data.db\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Create Database Tables\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Database tables created at data/energy_data.db\n"
     ]
    }
   ],
   "source": [
    "# Create the database tables\n",
    "# Use the create_tables() method from your DatabaseManager\n",
    "db_manager.create_tables()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Generate Sample Energy Usage Data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Created 2160 energy usage records\n"
     ]
    }
   ],
   "source": [
    "# Generate sample energy usage data for the past 30 days\n",
    "# Include different device types: EV, HVAC, appliances\n",
    "# Use realistic consumption patterns (higher during peak hours)\n",
    "\n",
    "# Device types and their typical consumption patterns\n",
    "device_types = {\n",
    "    'EV': {'base_kwh': 10, 'variation': 5, 'peak_hours': [18, 19, 20, 21]},\n",
    "    'HVAC': {'base_kwh': 2, 'variation': 1, 'peak_hours': [12, 13, 14, 15, 16, 17]},\n",
    "    'appliance': {'base_kwh': 1.5, 'variation': 0.5, 'peak_hours': [19, 20, 21, 22]}\n",
    "}\n",
    "\n",
    "# Generate data for the past 30 days\n",
    "start_date = datetime.now() - timedelta(days=30)\n",
    "records_created = 0\n",
    "\n",
    "for day in range(30):\n",
    "    current_date = start_date + timedelta(days=day)\n",
    "    \n",
    "    for hour in range(24):\n",
    "        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)\n",
    "        \n",
    "        # Generate usage for each device type\n",
    "        for device_type, config in device_types.items():\n",
    "            # Base consumption with variation\n",
    "            base_consumption = config['base_kwh']\n",
    "            variation = random.uniform(-config['variation'], config['variation'])\n",
    "            \n",
    "            # Peak hour multiplier\n",
    "            peak_multiplier = 1.5 if hour in config['peak_hours'] else 0.8\n",
    "            \n",
    "            consumption = max(0, (base_consumption + variation) * peak_multiplier)\n",
    "            \n",
    "            # Calculate cost (simplified pricing)\n",
    "            price_per_kwh = 0.15 if hour in config['peak_hours'] else 0.10\n",
    "            cost = consumption * price_per_kwh\n",
    "            \n",
    "            # Device names\n",
    "            device_names = {\n",
    "                'EV': 'Tesla Model 3',\n",
    "                'HVAC': 'Main AC Unit',\n",
    "                'appliance': random.choice(['Dishwasher', 'Washing Machine', 'Dryer'])\n",
    "            }\n",
    "            \n",
    "            # Add record to database\n",
    "            db_manager.add_usage_record(\n",
    "                timestamp=timestamp,\n",
    "                consumption_kwh=consumption,\n",
    "                device_type=device_type,\n",
    "                device_name=device_names[device_type],\n",
    "                cost_usd=cost\n",
    "            )\n",
    "            records_created += 1\n",
    "\n",
    "print(f\"Created {records_created} energy usage records\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Generate Sample Solar Generation Data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Created 390 solar generation records\n"
     ]
    }
   ],
   "source": [
    "# Generate sample solar generation data\n",
    "# Consider weather patterns, time of day, and seasonal variations\n",
    "\n",
    "# Weather conditions and their impact on solar generation\n",
    "weather_conditions = {\n",
    "    'sunny': {'multiplier': 1.0, 'probability': 0.4},\n",
    "    'partly_cloudy': {'multiplier': 0.6, 'probability': 0.3},\n",
    "    'cloudy': {'multiplier': 0.3, 'probability': 0.2},\n",
    "    'rainy': {'multiplier': 0.1, 'probability': 0.1}\n",
    "}\n",
    "\n",
    "# Generate solar generation data for the same period\n",
    "start_date = datetime.now() - timedelta(days=30)\n",
    "generation_records = 0\n",
    "\n",
    "for day in range(30):\n",
    "    current_date = start_date + timedelta(days=day)\n",
    "    \n",
    "    # Select weather condition for the day\n",
    "    weather_choice = random.choices(\n",
    "        list(weather_conditions.keys()),\n",
    "        weights=[weather_conditions[w]['probability'] for w in weather_conditions.keys()]\n",
    "    )[0]\n",
    "    weather_multiplier = weather_conditions[weather_choice]['multiplier']\n",
    "    \n",
    "    for hour in range(24):\n",
    "        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)\n",
    "        \n",
    "        # Solar generation only during daylight hours (6 AM to 6 PM)\n",
    "        if 6 <= hour <= 18:\n",
    "            # Base generation curve (peak at noon)\n",
    "            hour_factor = 1 - abs(hour - 12) / 6  # Peak at hour 12\n",
    "            base_generation = 5.0 * hour_factor  # Max 5 kWh at peak\n",
    "            \n",
    "            # Apply weather multiplier\n",
    "            generation = base_generation * weather_multiplier\n",
    "            \n",
    "            # Add some random variation\n",
    "            generation *= random.uniform(0.8, 1.2)\n",
    "            generation = max(0, generation)\n",
    "            \n",
    "            # Calculate temperature (affects solar efficiency)\n",
    "            base_temp = 20 + random.uniform(-5, 5)\n",
    "            temp_factor = 1.0 if 15 <= base_temp <= 35 else 0.9\n",
    "            \n",
    "            # Solar irradiance calculation\n",
    "            irradiance = 800 * hour_factor * weather_multiplier if generation > 0 else 0\n",
    "            \n",
    "            # Add record to database\n",
    "            db_manager.add_generation_record(\n",
    "                timestamp=timestamp,\n",
    "                generation_kwh=generation,\n",
    "                weather_condition=weather_choice,\n",
    "                temperature_c=base_temp * temp_factor,\n",
    "                solar_irradiance=irradiance\n",
    "            )\n",
    "            generation_records += 1\n",
    "\n",
    "print(f\"Created {generation_records} solar generation records\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Query and Analyze Data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Energy Usage Analysis ===\n",
      "Total records in last 24 hours: 105\n",
      "\n",
      "Consumption by device type:\n",
      "  EV: 409.75 kWh, $55.33, 35 records\n",
      "  HVAC: 62.32 kWh, $7.00, 35 records\n",
      "  appliance: 63.55 kWh, $8.69, 35 records\n",
      "\n",
      "=== Solar Generation Analysis ===\n",
      "Total generation records in last 24 hours: 10\n",
      "Total generation: 2.69 kWh\n",
      "\n",
      "Generation by weather condition:\n",
      "  sunny: 1.64 kWh, 4 records\n",
      "  partly_cloudy: 0.84 kWh, 4 records\n",
      "  cloudy: 0.21 kWh, 2 records\n"
     ]
    }
   ],
   "source": [
    "# Query the data to verify it was inserted correctly\n",
    "# Show total consumption by device type\n",
    "# Show daily solar generation patterns\n",
    "# Calculate some basic statistics\n",
    "\n",
    "# Get recent data for analysis\n",
    "recent_usage = db_manager.get_recent_usage(24)  # Last 24 hours\n",
    "recent_generation = db_manager.get_recent_generation(24)\n",
    "\n",
    "print(\"=== Energy Usage Analysis ===\")\n",
    "print(f\"Total records in last 24 hours: {len(recent_usage)}\")\n",
    "\n",
    "# Group by device type\n",
    "device_consumption = {}\n",
    "for record in recent_usage:\n",
    "    device = record.device_type or 'unknown'\n",
    "    if device not in device_consumption:\n",
    "        device_consumption[device] = {'kwh': 0, 'cost': 0, 'records': 0}\n",
    "    device_consumption[device]['kwh'] += record.consumption_kwh\n",
    "    device_consumption[device]['cost'] += record.cost_usd or 0\n",
    "    device_consumption[device]['records'] += 1\n",
    "\n",
    "print(\"\\nConsumption by device type:\")\n",
    "for device, data in device_consumption.items():\n",
    "    print(f\"  {device}: {data['kwh']:.2f} kWh, ${data['cost']:.2f}, {data['records']} records\")\n",
    "\n",
    "print(f\"\\n=== Solar Generation Analysis ===\")\n",
    "print(f\"Total generation records in last 24 hours: {len(recent_generation)}\")\n",
    "\n",
    "total_generation = sum(r.generation_kwh for r in recent_generation)\n",
    "print(f\"Total generation: {total_generation:.2f} kWh\")\n",
    "\n",
    "# Weather breakdown\n",
    "weather_breakdown = {}\n",
    "for record in recent_generation:\n",
    "    weather = record.weather_condition or 'unknown'\n",
    "    if weather not in weather_breakdown:\n",
    "        weather_breakdown[weather] = {'kwh': 0, 'records': 0}\n",
    "    weather_breakdown[weather]['kwh'] += record.generation_kwh\n",
    "    weather_breakdown[weather]['records'] += 1\n",
    "\n",
    "print(\"\\nGeneration by weather condition:\")\n",
    "for weather, data in weather_breakdown.items():\n",
    "    print(f\"  {weather}: {data['kwh']:.2f} kWh, {data['records']} records\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Test Database Tools\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/homebrew/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
      "  from .autonotebook import tqdm as notebook_tqdm\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Testing Database Tools ===\n",
      "Querying data from 2025-10-09 to 2025-10-16\n",
      "\n",
      "Energy Usage Query Results:\n",
      "  Total records: 5040\n",
      "  Total consumption: 21048.02 kWh\n",
      "  Total cost: $2413.83\n",
      "\n",
      "Solar Generation Query Results:\n",
      "  Total records: 910\n",
      "  Total generation: 1358.64 kWh\n",
      "  Average daily: 169.83 kWh\n",
      "\n",
      "Recent Energy Summary:\n",
      "  Usage: 535.62 kWh, $71.01\n",
      "  Generation: 2.69 kWh\n",
      "  Weather: sunny\n"
     ]
    }
   ],
   "source": [
    "# Test the database query functions from tools.py\n",
    "# Import and test: query_energy_usage, query_solar_generation, get_recent_energy_summary\n",
    "\n",
    "from tools import query_energy_usage, query_solar_generation, get_recent_energy_summary\n",
    "\n",
    "# Test querying data for the last 7 days\n",
    "end_date = datetime.now().strftime(\"%Y-%m-%d\")\n",
    "start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n",
    "\n",
    "print(\"=== Testing Database Tools ===\")\n",
    "print(f\"Querying data from {start_date} to {end_date}\")\n",
    "\n",
    "# Test energy usage query\n",
    "usage_data = query_energy_usage.invoke(\n",
    "    input={\n",
    "        \"start_date\": start_date, \n",
    "        \"end_date\": end_date,\n",
    "    }\n",
    ")\n",
    "print(f\"\\nEnergy Usage Query Results:\")\n",
    "print(f\"  Total records: {usage_data['total_records']}\")\n",
    "print(f\"  Total consumption: {usage_data['total_consumption_kwh']} kWh\")\n",
    "print(f\"  Total cost: ${usage_data['total_cost_usd']}\")\n",
    "\n",
    "# Test solar generation query\n",
    "generation_data = query_solar_generation.invoke(\n",
    "    input={\n",
    "        \"start_date\": start_date, \n",
    "        \"end_date\": end_date,\n",
    "    }\n",
    ")\n",
    "print(f\"\\nSolar Generation Query Results:\")\n",
    "print(f\"  Total records: {generation_data['total_records']}\")\n",
    "print(f\"  Total generation: {generation_data['total_generation_kwh']} kWh\")\n",
    "print(f\"  Average daily: {generation_data['average_daily_generation']} kWh\")\n",
    "\n",
    "# Test recent energy summary\n",
    "summary = get_recent_energy_summary.invoke(\n",
    "    input={\n",
    "        \"hours\": 24\n",
    "    }\n",
    ")\n",
    "print(f\"\\nRecent Energy Summary:\")\n",
    "print(f\"  Usage: {summary['usage']['total_consumption_kwh']} kWh, ${summary['usage']['total_cost_usd']}\")\n",
    "print(f\"  Generation: {summary['generation']['total_generation_kwh']} kWh\")\n",
    "print(f\"  Weather: {summary['generation']['average_weather']}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
</file_content>

<file_content path="02_rag_setup.ipynb">
{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# EcoHome Energy Advisor - RAG Setup\n",
        "\n",
        "In this notebook, you'll set up the Retrieval-Augmented Generation (RAG) pipeline for the EcoHome Energy Advisor. This will allow the agent to access and cite relevant energy-saving tips and best practices.\n",
        "\n",
        "## Learning Objectives\n",
        "- Set up ChromaDB vector store\n",
        "- Load and process energy-saving documents\n",
        "- Create embeddings for document chunks\n",
        "- Implement semantic search functionality\n",
        "- Test the RAG pipeline\n",
        "\n",
        "## Documents Available\n",
        "- `tip_device_best_practices.txt` - Device-specific optimization tips\n",
        "- `tip_energy_savings.txt` - General energy-saving strategies\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 1. Import Required Libraries\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {},
      "outputs": [
        {
          "name": "stderr",
          "output_type": "stream",
          "text": [
            "/opt/homebrew/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
            "  from .autonotebook import tqdm as notebook_tqdm\n"
          ]
        }
      ],
      "source": [
        "# Import the necessary libraries for RAG setup\n",
        "import os\n",
        "from langchain_chroma  import Chroma\n",
        "from langchain_openai import OpenAIEmbeddings\n",
        "from langchain_community.document_loaders import TextLoader\n",
        "from langchain.text_splitter import RecursiveCharacterTextSplitter\n",
        "from dotenv import load_dotenv"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [
        {
          "data": {
            "text/plain": [
              "True"
            ]
          },
          "execution_count": 2,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "load_dotenv()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2. Load and Process Documents\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Loaded 1 documents from data/documents/tip_renewable_energy_integration.txt\n",
            "Loaded 1 documents from data/documents/tip_device_best_practices.txt\n",
            "Loaded 1 documents from data/documents/tip_hvac_optimization.txt\n",
            "Loaded 1 documents from data/documents/tip_energy_storage_optimization.txt\n",
            "Loaded 1 documents from data/documents/tip_energy_savings.txt\n",
            "Loaded 1 documents from data/documents/tip_smart_home_automation.txt\n",
            "Loaded 1 documents from data/documents/tip_seasonal_energy_management.txt\n",
            "Total documents loaded: 7\n"
          ]
        }
      ],
      "source": [
        "# Load the energy-saving tip documents\n",
        "# Load all .txt files from the data/documents directory\n",
        "# Use TextLoader to load the documents\n",
        "\n",
        "documents = []\n",
        "doc_dir = \"data/documents\"\n",
        "document_paths = [os.path.join(doc_dir, f) for f in os.listdir(doc_dir) if f.endswith(\".txt\")]\n",
        "\n",
        "for doc_path in document_paths:\n",
        "    if os.path.exists(doc_path):\n",
        "        loader = TextLoader(doc_path)\n",
        "        docs = loader.load()\n",
        "        documents.extend(docs)\n",
        "        print(f\"Loaded {len(docs)} documents from {doc_path}\")\n",
        "    else:\n",
        "        print(f\"Warning: {doc_path} not found\")\n",
        "\n",
        "print(f\"Total documents loaded: {len(documents)}\")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 3. Split Documents into Chunks\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Split 7 documents into 25 chunks\n",
            "\n",
            "Sample chunk (first 200 characters):\n",
            "Renewable Energy Integration\n",
            "\n",
            "1.  Solar Photovoltaic (PV) Systems:\n",
            "    *   **Grid-Tied Systems:** Connected to the utility grid, allowing you to draw power when solar production is low and send excess...\n"
          ]
        }
      ],
      "source": [
        "# Split documents into smaller chunks for better retrieval\n",
        "# Use RecursiveCharacterTextSplitter with appropriate chunk_size and chunk_overlap\n",
        "# Experiment with different chunk sizes (e.g., 500, 1000, 1500 characters)\n",
        "\n",
        "text_splitter = RecursiveCharacterTextSplitter(\n",
        "    chunk_size=1000,\n",
        "    chunk_overlap=200,\n",
        "    length_function=len,\n",
        "    separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n",
        ")\n",
        "\n",
        "# Split the documents\n",
        "splits = text_splitter.split_documents(documents)\n",
        "print(f\"Split {len(documents)} documents into {len(splits)} chunks\")\n",
        "\n",
        "# Show sample chunk\n",
        "if splits:\n",
        "    print(f\"\\nSample chunk (first 200 characters):\")\n",
        "    print(splits[0].page_content[:200] + \"...\")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 4. Create Vector Store\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Vector store created and persisted to data/vectorstore\n",
            "Total vectors stored: 25\n"
          ]
        }
      ],
      "source": [
        "# Create a ChromaDB vector store\n",
        "# Initialize OpenAIEmbeddings\n",
        "# Create the vector store with the document chunks\n",
        "# Persist the vector store to disk for future use\n",
        "\n",
        "# Set up the persist directory\n",
        "persist_directory = \"data/vectorstore\"\n",
        "os.makedirs(persist_directory, exist_ok=True)\n",
        "\n",
        "# Initialize embeddings\n",
        "embeddings = OpenAIEmbeddings(\n",
        "    base_url=\"https://openai.vocareum.com/v1\",\n",
        "    api_key=os.getenv(\"VOCAREUM_API_KEY\")\n",
        ")\n",
        "\n",
        "# Create the vector store\n",
        "vectorstore = Chroma.from_documents(\n",
        "    documents=splits,\n",
        "    embedding=embeddings,\n",
        "    persist_directory=persist_directory\n",
        ")\n",
        "\n",
        "print(f\"Vector store created and persisted to {persist_directory}\")\n",
        "print(f\"Total vectors stored: {len(splits)}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 5. Test the RAG Pipeline\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 6,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "=== Testing Vector Search ===\n",
            "\n",
            "Query: 'electric vehicle charging tips'\n",
            "  Result 1: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "  Result 2: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "\n",
            "Query: 'thermostat optimization'\n",
            "  Result 1: # HVAC System Optimization Strategies\n",
            "\n",
            "## Temperature Management\n",
            "\n",
            "### Optimal Thermostat Settings\n",
            "- ...\n",
            "  Result 2: # HVAC System Optimization Strategies\n",
            "\n",
            "## Temperature Management\n",
            "\n",
            "### Optimal Thermostat Settings\n",
            "- ...\n",
            "\n",
            "Query: 'dishwasher energy saving'\n",
            "  Result 1: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n",
            "  Result 2: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n",
            "\n",
            "Query: 'solar power maximization'\n",
            "  Result 1: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "  Result 2: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "\n",
            "Query: 'HVAC system efficiency'\n",
            "  Result 1: ### Annual Professional Maintenance\n",
            "- Schedule professional HVAC inspection annually\n",
            "- Clean coils, ...\n",
            "  Result 2: ### Annual Professional Maintenance\n",
            "- Schedule professional HVAC inspection annually\n",
            "- Clean coils, ...\n",
            "\n",
            "Query: 'pool pump scheduling'\n",
            "  Result 1: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n",
            "  Result 2: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n"
          ]
        }
      ],
      "source": [
        "# Test the search functionality\n",
        "# Try different queries related to energy optimization\n",
        "# Test queries like:\n",
        "# - \"electric vehicle charging tips\"\n",
        "# - \"thermostat optimization\"\n",
        "# - \"dishwasher energy saving\"\n",
        "# - \"solar power maximization\"\n",
        "\n",
        "test_queries = [\n",
        "    \"electric vehicle charging tips\",\n",
        "    \"thermostat optimization\",\n",
        "    \"dishwasher energy saving\",\n",
        "    \"solar power maximization\",\n",
        "    \"HVAC system efficiency\",\n",
        "    \"pool pump scheduling\"\n",
        "]\n",
        "\n",
        "print(\"=== Testing Vector Search ===\")\n",
        "for query in test_queries:\n",
        "    print(f\"\\nQuery: '{query}'\")\n",
        "    docs = vectorstore.similarity_search(query, k=2)\n",
        "    for i, doc in enumerate(docs):\n",
        "        print(f\"  Result {i+1}: {doc.page_content[:100]}...\")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 6. Test the Search Tool\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 7,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "=== Testing search_energy_tips Tool ===\n",
            "\n",
            "Query: 'electric vehicle charging'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n",
            "\n",
            "Query: 'thermostat settings'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n",
            "\n",
            "Query: 'dishwasher optimization'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n",
            "\n",
            "Query: 'solar power tips'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n"
          ]
        }
      ],
      "source": [
        "# Test the search_energy_tips tool from tools.py\n",
        "# Import and test the tool with various queries\n",
        "# Verify that it returns relevant results\n",
        "\n",
        "from tools import search_energy_tips\n",
        "\n",
        "# Test the search_energy_tips function\n",
        "print(\"=== Testing search_energy_tips Tool ===\")\n",
        "\n",
        "test_queries = [\n",
        "    \"electric vehicle charging\",\n",
        "    \"thermostat settings\",\n",
        "    \"dishwasher optimization\",\n",
        "    \"solar power tips\"\n",
        "]\n",
        "\n",
        "for query in test_queries:\n",
        "    print(f\"\\nQuery: '{query}'\")\n",
        "    result = search_energy_tips.invoke(\n",
        "        input={\n",
        "            \"query\": query, \n",
        "            \"max_results\": 3,\n",
        "        }\n",
        "    )\n",
        "    \n",
        "    if \"error\" in result:\n",
        "        print(f\"  Error: {result['error']}\")\n",
        "    else:\n",
        "        print(f\"  Found {result['total_results']} results\")\n",
        "        for i, tip in enumerate(result['tips']):\n",
        "            print(f\"    {i+1}. {tip['content'][:100]}...\")\n",
        "            print(f\"       Source: {tip['source']}\")\n",
        "            print(f\"       Relevance: {tip['relevance_score']}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.11.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}
</file_content>

<file_content path="03_run_and_evaluate.ipynb">
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "b8860961",
   "metadata": {},
   "source": [
    "# EcoHome Energy Advisor - Agent Run & Evaluation\\n\n",
    "\\n\n",
    "In this notebook, you'll run the Energy Advisor agent with various real-world scenarios and see how it helps customers optimize their energy usage.\\n\n",
    "\\n\n",
    "## Learning Objectives\\n\n",
    "- Create the agent's instructions\\n\n",
    "- Run the Energy Advisor with different types of questions\\n\n",
    "- Evaluate response quality and accuracy\\n\n",
    "- Measure tool usage effectiveness\\n\n",
    "- Identify areas for improvement\\n\n",
    "- Implement evaluation metrics\\n\n",
    "\\n\n",
    "## Evaluation Criteria\\n\n",
    "- **Accuracy**: Correct information and calculations\\n\n",
    "- **Relevance**: Responses address the user's question\\n\n",
    "- **Completeness**: Comprehensive answers with actionable advice\\n\n",
    "- **Tool Usage**: Appropriate use of available tools\\n\n",
    "- **Reasoning**: Clear explanation of recommendations\\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce6ffc7d",
   "metadata": {},
   "source": [
    "## 1. Import and Initialize"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "b989c804",
   "metadata": {},
   "outputs": [],
   "source": [
    "from datetime import datetime\n",
    "from agent import Agent"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "0d063734",
   "metadata": {},
   "outputs": [],
   "source": [
    "ECOHOME_SYSTEM_PROMPT = \"\"\"# EcoHome Energy Advisor: System Prompt\n",
    "\n",
    "## Role and Goal\n",
    "\n",
    "You are the EcoHome Energy Advisor, an advanced AI assistant from EcoHome Inc. Your primary goal is to help users optimize their home energy consumption, reduce costs, and minimize their environmental impact. You must provide accurate, data-driven, and actionable recommendations in a friendly, clear, and professional tone.\n",
    "\n",
    "## Step-by-Step Operation\n",
    "\n",
    "1.  **Analyze User Request**: Carefully review the user's question and any provided context (e.g., location, devices, preferences).\n",
    "2.  **Gather Data**: Use the available tools to collect real-time data, such as weather forecasts, electricity prices, and historical energy usage.\n",
    "3.  **Consult Knowledge Base**: Search the knowledge base for relevant energy-saving tips, best practices, and device-specific advice.\n",
    "4.  **Synthesize Findings**: Combine the collected data and knowledge to formulate a comprehensive and customized recommendation.\n",
    "5.  **Deliver Actionable Advice**: Present the final recommendation in a clear, structured, and easy-to-understand format. Include specific actions the user can take.\n",
    "\n",
    "## Key Capabilities\n",
    "\n",
    "*   **Energy Data Analysis**: Analyze historical energy usage and solar generation data to identify patterns and opportunities for improvement.\n",
    "*   **Weather-Informed Advice**: Use weather forecasts to provide proactive recommendations (e.g., pre-cooling your home before a heatwave).\n",
    "*   **Cost Optimization**: Factor in real-time electricity prices to recommend cost-effective energy schedules.\n",
    "*   **Knowledge Retrieval**: Access a rich knowledge base of energy-saving tips for various devices and scenarios.\n",
    "\n",
    "## Recommendation Instructions\n",
    "\n",
    "*   **Be Specific**: Provide concrete recommendations with clear, actionable steps (e.g., \"Set your thermostat to 78Â°F between 2 PM and 6 PM\").\n",
    "*   **Justify Recommendations**: Explain *why* you are making a recommendation, citing data from the tools (e.g., \"Electricity prices are highest during these hours\").\n",
    "*   **Format for Clarity**: Use headings, bullet points, and bold text to structure your response and improve readability.\n",
    "*   **Cite Sources**: When you use information from the knowledge base, cite the source document (e.g., \"Source: `tip_hvac_optimization.txt`\").\n",
    "\n",
    "## Example Questions\n",
    "\n",
    "*   \"When is the best time to charge my EV tomorrow to save money?\"\n",
    "*   \"How can I lower my air conditioning costs during the summer?\"\n",
    "*   \"What are some tips for reducing my dishwasher's energy consumption?\"\n",
    "*   \"How can I maximize my solar panel output on a cloudy day?\"\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "1aaa54a3",
   "metadata": {},
   "outputs": [],
   "source": [
    "ecohome_agent = Agent(\n",
    "    instructions=ECOHOME_SYSTEM_PROMPT,\n",
    "    model=\"gpt-4o-mini\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "05d2730e",
   "metadata": {},
   "source": [
    "## 2. Define Test Cases"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "aefe0d45",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_cases = [\n",
    "    {\n",
    "        \"id\": \"ev_charging_cost\",\n",
    "        \"question\": \"When is the cheapest time to charge my EV tomorrow?\",\n",
    "        \"expected_tools\": [\"get_electricity_prices\"],\n",
    "        \"expected_response\": \"The response should recommend charging during off-peak hours and mention the specific time range.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"ev_charging_solar\",\n",
    "        \"question\": \"I want to charge my EV tomorrow using only solar power. When should I do it?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\"],\n",
    "        \"expected_response\": \"The response should recommend charging during peak solar generation hours and consider cloud cover.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"hvac_cost_savings\",\n",
    "        \"question\": \"How can I save money on my AC bill this summer?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide tips on thermostat settings, maintenance, and using fans, citing the HVAC optimization document.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"hvac_pre_cooling\",\n",
    "        \"question\": \"There is a heatwave tomorrow. How should I set my thermostat?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\", \"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should recommend pre-cooling the house before the peak heat and adjusting the thermostat during the day.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"appliance_scheduling\",\n",
    "        \"question\": \"When is the best time to run my dishwasher and washing machine?\",\n",
    "        \"expected_tools\": [\"get_electricity_prices\"],\n",
    "        \"expected_response\": \"The response should recommend running appliances during off-peak hours to save on electricity costs.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"solar_maximization_cloudy\",\n",
    "        \"question\": \"It's going to be cloudy tomorrow. How can I maximize my solar panel output?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\", \"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide tips on cleaning panels and reducing consumption during cloudy periods.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"solar_maximization_sunny\",\n",
    "        \"question\": \"It will be sunny all week. How can I make the most of my solar panels?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\", \"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should recommend shifting energy-intensive tasks to peak solar hours.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"general_energy_savings\",\n",
    "        \"question\": \"What are some general tips for saving energy at home?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide a variety of tips from the knowledge base, covering different aspects of home energy use.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"device_best_practices\",\n",
    "        \"question\": \"What are the best practices for using my refrigerator efficiently?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide specific tips for refrigerator use, citing the device best practices document.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"seasonal_energy_management\",\n",
    "        \"question\": \"How should my energy habits change from winter to summer?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide seasonal tips, such as adjusting thermostat settings and using appliances differently in different seasons, citing the seasonal energy management document.\"\n",
    "    }\n",
    "]\n",
    "\n",
    "if len(test_cases) < 10:\n",
    "    raise ValueError(\"You MUST have at least 10 test cases\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2cdde81",
   "metadata": {},
   "source": [
    "## 3. Run Agent Tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "b8eb83e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "CONTEXT = \"Location: San Francisco, CA\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "e9dc82e8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Running Agent Tests ===\n",
      "\n",
      "Test 1: ev_charging_cost\n",
      "Question: When is the cheapest time to charge my EV tomorrow?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 2: ev_charging_solar\n",
      "Question: I want to charge my EV tomorrow using only solar power. When should I do it?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 3: hvac_cost_savings\n",
      "Question: How can I save money on my AC bill this summer?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 4: hvac_pre_cooling\n",
      "Question: There is a heatwave tomorrow. How should I set my thermostat?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 5: appliance_scheduling\n",
      "Question: When is the best time to run my dishwasher and washing machine?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 6: solar_maximization_cloudy\n",
      "Question: It's going to be cloudy tomorrow. How can I maximize my solar panel output?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 7: solar_maximization_sunny\n",
      "Question: It will be sunny all week. How can I make the most of my solar panels?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 8: general_energy_savings\n",
      "Question: What are some general tips for saving energy at home?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 9: device_best_practices\n",
      "Question: What are the best practices for using my refrigerator efficiently?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 10: seasonal_energy_management\n",
      "Question: How should my energy habits change from winter to summer?\n",
      "--------------------------------------------------\n",
      "\n",
      "Completed 10 tests\n"
     ]
    }
   ],
   "source": [
    "print(\"=== Running Agent Tests ===\")\n",
    "test_results = []\n",
    "\n",
    "for i, test_case in enumerate(test_cases):\n",
    "    print(f\"\\nTest {i+1}: {test_case['id']}\")\n",
    "    print(f\"Question: {test_case['question']}\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    try:\n",
    "        response = ecohome_agent.invoke(\n",
    "            question=test_case['question'],\n",
    "            context=CONTEXT\n",
    "        )\n",
    "        \n",
    "        result = {\n",
    "            'test_id': test_case['id'],\n",
    "            'question': test_case['question'],\n",
    "            'response': response,\n",
    "            'expected_tools': test_case['expected_tools'],\n",
    "            'expected_response': test_case['expected_response'],\n",
    "            'timestamp': datetime.now().isoformat()\n",
    "        }\n",
    "        test_results.append(result)\n",
    "                \n",
    "    except Exception as e:\n",
    "        print(f\"Error: {e}\")\n",
    "        result = {\n",
    "            'test_id': test_case['id'],\n",
    "            'question': test_case['question'],\n",
    "            'response': f\"Error: {str(e)}\",\n",
    "            'expected_tools': test_case['expected_tools'],\n",
    "            'expected_response': test_case['expected_response'],\n",
    "            'timestamp': datetime.now().isoformat(),\n",
    "            'error': str(e)\n",
    "        }\n",
    "        test_results.append(result)\n",
    "\n",
    "print(f\"\\nCompleted {len(test_results)} tests\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5760814c",
   "metadata": {},
   "source": [
    "## 4. Evaluate Responses"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "1da0640e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def evaluate_response(question, final_response, expected_response):\n",
    "    \"\"\"\n",
    "    Evaluate a single agent response based on a set of criteria.\n",
    "    \n",
    "    Metrics:\n",
    "    - ACCURACY: Based on keywords from expected response.\n",
    "    - RELEVANCE: Is the response related to the question? (simple check)\n",
    "    - COMPLETENESS: Does the response provide justification? (e.g., 'because')\n",
    "    - USEFULNESS: Does the response give actionable advice? (e.g., 'recommend')\n",
    "    \"\"\"\n",
    "    \n",
    "    scores = {}\n",
    "    feedback = []\n",
    "    final_response_lower = final_response.lower()\n",
    "    question_lower = question.lower()\n",
    "\n",
    "    # RELEVANCE\n",
    "    question_words = set(question_lower.split())\n",
    "    if any(word in final_response_lower for word in question_words):\n",
    "        scores['RELEVANCE'] = 1.0\n",
    "        feedback.append(\"Response is relevant to the question.\")\n",
    "    else:\n",
    "        scores['RELEVANCE'] = 0.0\n",
    "        feedback.append(\"Response may not be relevant.\")\n",
    "\n",
    "    # ACCURACY & COMPLETENESS (using expected_response as keywords)\n",
    "    expected_keywords = set(expected_response.lower().replace('.', '').split())\n",
    "    found_keywords = [kw for kw in expected_keywords if kw in final_response_lower]\n",
    "    accuracy_score = len(found_keywords) / len(expected_keywords) if expected_keywords else 0\n",
    "    scores['ACCURACY'] = accuracy_score\n",
    "    scores['COMPLETENESS'] = accuracy_score  # Use same score as a proxy\n",
    "    if accuracy_score > 0.7:\n",
    "        feedback.append(f\"Response contains {len(found_keywords)}/{len(expected_keywords)} expected keywords.\")\n",
    "    else:\n",
    "        feedback.append(f\"Response is missing many expected keywords (found {len(found_keywords)}/{len(expected_keywords)}).\")\n",
    "\n",
    "    # USEFULNESS\n",
    "    if \"recommend\" in final_response_lower or \"you should\" in final_response_lower:\n",
    "        scores['USEFULNESS'] = 1.0\n",
    "        feedback.append(\"Response provides actionable advice.\")\n",
    "    else:\n",
    "        scores['USEFULNESS'] = 0.0\n",
    "        feedback.append(\"Response could be more actionable.\")\n",
    "        \n",
    "    overall_score = sum(scores.values()) / len(scores)\n",
    "\n",
    "    return {\n",
    "        \"overall_score\": overall_score,\n",
    "        \"metrics\": scores,\n",
    "        \"feedback\": \" \".join(feedback)\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "7e0dc154",
   "metadata": {},
   "outputs": [],
   "source": [
    "def evaluate_tool_usage(messages, expected_tools):\n",
    "    \"\"\"\n",
    "    Evaluate if the right tools were used with comprehensive metrics.\n",
    "    \n",
    "    Metrics:\n",
    "    - Tool Appropriateness: Were the right tools selected for the task?\n",
    "    - Tool Completeness: Were all necessary tools used?\n",
    "    \n",
    "    Returns comprehensive feedback for tool usage evaluation.\n",
    "    \"\"\"\n",
    "    \n",
    "    used_tools = set()\n",
    "    for message in messages:\n",
    "        if hasattr(message, 'tool_calls') and message.tool_calls:\n",
    "            for tool_call in message.tool_calls:\n",
    "                used_tools.add(tool_call[\"name\"])\n",
    "    \n",
    "    expected_tools = set(expected_tools)\n",
    "    \n",
    "    correct_tools = used_tools.intersection(expected_tools)\n",
    "    missed_tools = expected_tools.difference(used_tools)\n",
    "    extra_tools = used_tools.difference(expected_tools)\n",
    "    \n",
    "    # Calculate metrics\n",
    "    # Tool Appropriateness: Ratio of correct tools to used tools (measures precision)\n",
    "    # Were the right tools selected? Penalizes using unnecessary/wrong tools\n",
    "    if len(used_tools) > 0:\n",
    "        tool_appropriateness = len(correct_tools) / len(used_tools)\n",
    "    else:\n",
    "        # If no tools were used but tools were expected, appropriateness is 0\n",
    "        tool_appropriateness = 0.0 if len(expected_tools) > 0 else 1.0\n",
    "    \n",
    "    # Tool Completeness: Ratio of correct tools to expected tools (measures recall)\n",
    "    # Were all necessary tools used? Penalizes missing required tools\n",
    "    if len(expected_tools) > 0:\n",
    "        tool_completeness = len(correct_tools) / len(expected_tools)\n",
    "    else:\n",
    "        # If no tools were expected, completeness is 1.0\n",
    "        tool_completeness = 1.0\n",
    "    \n",
    "    # Overall tool usage score (F1-like score combining appropriateness and completeness)\n",
    "    if tool_appropriateness + tool_completeness > 0:\n",
    "        overall_tool_score = 2 * (tool_appropriateness * tool_completeness) / (tool_appropriateness + tool_completeness)\n",
    "    else:\n",
    "        overall_tool_score = 0.0\n",
    "    \n",
    "    # Generate comprehensive feedback\n",
    "    feedback = []\n",
    "    \n",
    "    if len(correct_tools) == len(expected_tools) and len(extra_tools) == 0:\n",
    "        feedback.append(\"Perfect tool selection! All expected tools were used and no unnecessary tools were called.\")\n",
    "    else:\n",
    "        # Feedback on appropriateness\n",
    "        if tool_appropriateness >= 0.9:\n",
    "            feedback.append(f\"Excellent tool appropriateness ({tool_appropriateness:.0%}): Agent selected the right tools.\")\n",
    "        elif tool_appropriateness >= 0.7:\n",
    "            feedback.append(f\"Good tool appropriateness ({tool_appropriateness:.0%}): Most tools selected were correct.\")\n",
    "        elif tool_appropriateness >= 0.5:\n",
    "            feedback.append(f\"Fair tool appropriateness ({tool_appropriateness:.0%}): Some incorrect tools were used.\")\n",
    "        else:\n",
    "            feedback.append(f\"Poor tool appropriateness ({tool_appropriateness:.0%}): Many incorrect or unnecessary tools were used.\")\n",
    "        \n",
    "        # Feedback on completeness\n",
    "        if tool_completeness >= 0.9:\n",
    "            feedback.append(f\"Excellent tool completeness ({tool_completeness:.0%}): Agent used almost all necessary tools.\")\n",
    "        elif tool_completeness >= 0.7:\n",
    "            feedback.append(f\"Good tool completeness ({tool_completeness:.0%}): Most necessary tools were used.\")\n",
    "        elif tool_completeness >= 0.5:\n",
    "            feedback.append(f\"Fair tool completeness ({tool_completeness:.0%}): Some necessary tools were missed.\")\n",
    "        else:\n",
    "            feedback.append(f\"Poor tool completeness ({tool_completeness:.0%}): Many necessary tools were not used.\")\n",
    "    \n",
    "    # Specific feedback on tool usage\n",
    "    if len(correct_tools) > 0:\n",
    "        feedback.append(f\"Correctly used: {', '.join(sorted(correct_tools))}.\")\n",
    "    \n",
    "    if len(missed_tools) > 0:\n",
    "        feedback.append(f\"Missed tools: {', '.join(sorted(missed_tools))}.\")\n",
    "    \n",
    "    if len(extra_tools) > 0:\n",
    "        feedback.append(f\"Extra tools used: {', '.join(sorted(extra_tools))}.\")\n",
    "    \n",
    "    return {\n",
    "        \"score\": overall_tool_score,\n",
    "        \"metrics\": {\n",
    "            \"TOOL_APPROPRIATENESS\": tool_appropriateness,\n",
    "            \"TOOL_COMPLETENESS\": tool_completeness\n",
    "        },\n",
    "        \"used_tools\": list(used_tools),\n",
    "        \"expected_tools\": list(expected_tools),\n",
    "        \"correct_tools\": list(correct_tools),\n",
    "        \"missed_tools\": list(missed_tools),\n",
    "        \"extra_tools\": list(extra_tools),\n",
    "        \"feedback\": \" \".join(feedback)\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "9c3df271",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_evaluation_report(test_results):\n",
    "    \"\"\"\n",
    "    Generate a comprehensive evaluation report based on execution and metrics.\n",
    "\n",
    "    This function calculates overall scores and metrics, identifies strengths and\n",
    "    weaknesses, and provides recommendations for improvement.\n",
    "    \"\"\"\n",
    "\n",
    "    # Initialize metric accumulators\n",
    "    total_response_score = 0\n",
    "    total_tool_usage_score = 0\n",
    "    total_relevance = 0\n",
    "    total_accuracy = 0\n",
    "    total_completeness = 0\n",
    "    total_usefulness = 0\n",
    "    total_tool_appropriateness = 0\n",
    "    total_tool_completeness = 0\n",
    "\n",
    "    # Collect detailed evaluation data\n",
    "    evaluations = []\n",
    "\n",
    "    for result in test_results:\n",
    "        if 'error' in result:\n",
    "            continue\n",
    "\n",
    "        final_response_content = result[\"response\"][\"messages\"][-1].content\n",
    "        response_eval = evaluate_response(\n",
    "            result[\"question\"],\n",
    "            final_response_content,\n",
    "            result[\"expected_response\"]\n",
    "        )\n",
    "        tool_eval = evaluate_tool_usage(\n",
    "            result[\"response\"][\"messages\"],\n",
    "            result[\"expected_tools\"]\n",
    "        )\n",
    "\n",
    "        evaluations.append({\n",
    "            'test_id': result['test_id'],\n",
    "            'question': result['question'],\n",
    "            'response_eval': response_eval,\n",
    "            'tool_eval': tool_eval\n",
    "        })\n",
    "\n",
    "        total_response_score += response_eval[\"overall_score\"]\n",
    "        total_tool_usage_score += tool_eval[\"score\"]\n",
    "        total_relevance += response_eval[\"metrics\"][\"RELEVANCE\"]\n",
    "        total_accuracy += response_eval[\"metrics\"][\"ACCURACY\"]\n",
    "        total_completeness += response_eval[\"metrics\"][\"COMPLETENESS\"]\n",
    "        total_usefulness += response_eval[\"metrics\"][\"USEFULNESS\"]\n",
    "        total_tool_appropriateness += tool_eval[\"metrics\"][\"TOOL_APPROPRIATENESS\"]\n",
    "        total_tool_completeness += tool_eval[\"metrics\"][\"TOOL_COMPLETENESS\"]\n",
    "\n",
    "    num_successful_tests = len(evaluations)\n",
    "\n",
    "    if num_successful_tests == 0:\n",
    "        return \"# Evaluation Report\\n\\nNo successful test cases to evaluate.\"\n",
    "\n",
    "    # Calculate overall metrics\n",
    "    avg_response_score = total_response_score / num_successful_tests\n",
    "    avg_tool_usage_score = total_tool_usage_score / num_successful_tests\n",
    "    avg_relevance = total_relevance / num_successful_tests\n",
    "    avg_accuracy = total_accuracy / num_successful_tests\n",
    "    avg_completeness = total_completeness / num_successful_tests\n",
    "    avg_usefulness = total_usefulness / num_successful_tests\n",
    "    avg_tool_appropriateness = total_tool_appropriateness / num_successful_tests\n",
    "    avg_tool_completeness = total_tool_completeness / num_successful_tests\n",
    "\n",
    "    # Calculate weighted overall score (40% response quality, 30% tool usage, 30% individual metrics)\n",
    "    overall_score = (\n",
    "        avg_response_score * 0.4 +\n",
    "        avg_tool_usage_score * 0.3 +\n",
    "        (avg_relevance + avg_accuracy + avg_completeness + avg_usefulness) / 4 * 0.3\n",
    "    )\n",
    "\n",
    "    # Build the report\n",
    "    report = \"# EcoHome Energy Advisor: Comprehensive Evaluation Report\\n\\n\"\n",
    "\n",
    "    # Executive Summary\n",
    "    report += \"## Executive Summary\\n\\n\"\n",
    "    report += f\"This report evaluates the performance of the EcoHome Energy Advisor across {len(test_results)} test cases \"\n",
    "    report += f\"({num_successful_tests} successful, {len(test_results) - num_successful_tests} failed).\\n\\n\"\n",
    "\n",
    "    # Overall Scores and Metrics\n",
    "    report += \"## Overall Scores and Metrics\\n\\n\"\n",
    "    report += \"### Primary Metrics\\n\"\n",
    "    report += f\"- **Overall Score**: {overall_score:.2%} ({_get_grade(overall_score)})\\n\"\n",
    "    report += f\"- **Average Response Quality**: {avg_response_score:.2%}\\n\"\n",
    "    report += f\"- **Average Tool Usage**: {avg_tool_usage_score:.2%}\\n\\n\"\n",
    "\n",
    "    report += \"### Detailed Metrics\\n\"\n",
    "    report += f\"- **Relevance**: {avg_relevance:.2%} - How well responses address user questions\\n\"\n",
    "    report += f\"- **Accuracy**: {avg_accuracy:.2%} - Correctness of information and calculations\\n\"\n",
    "    report += f\"- **Completeness**: {avg_completeness:.2%} - Comprehensiveness of answers\\n\"\n",
    "    report += f\"- **Usefulness**: {avg_usefulness:.2%} - Actionability of recommendations\\n\"\n",
    "    report += f\"- **Tool Appropriateness**: {avg_tool_appropriateness:.2%} - Were the right tools selected?\\n\"\n",
    "    report += f\"- **Tool Completeness**: {avg_tool_completeness:.2%} - Were all necessary tools used?\\n\\n\"\n",
    "\n",
    "    # Performance Distribution\n",
    "    report += \"### Performance Distribution\\n\"\n",
    "    excellent = sum(1 for e in evaluations if e['response_eval']['overall_score'] >= 0.9)\n",
    "    good = sum(1 for e in evaluations if 0.7 <= e['response_eval']['overall_score'] < 0.9)\n",
    "    fair = sum(1 for e in evaluations if 0.5 <= e['response_eval']['overall_score'] < 0.7)\n",
    "    poor = sum(1 for e in evaluations if e['response_eval']['overall_score'] < 0.5)\n",
    "\n",
    "    report += f\"- **Excellent (90%+)**: {excellent} tests\\n\"\n",
    "    report += f\"- **Good (70-89%)**: {good} tests\\n\"\n",
    "    report += f\"- **Fair (50-69%)**: {fair} tests\\n\"\n",
    "    report += f\"- **Poor (<50%)**: {poor} tests\\n\\n\"\n",
    "\n",
    "    # Strengths and Weaknesses\n",
    "    report += \"## Strengths and Weaknesses\\n\\n\"\n",
    "    report += \"### Strengths\\n\"\n",
    "\n",
    "    strengths = []\n",
    "    if avg_relevance >= 0.85:\n",
    "        strengths.append(f\"**High Relevance** ({avg_relevance:.0%}): Agent consistently addresses user questions directly\")\n",
    "    if avg_tool_usage_score >= 0.80:\n",
    "        strengths.append(f\"**Effective Tool Usage** ({avg_tool_usage_score:.0%}): Agent selects and uses appropriate tools\")\n",
    "    if avg_usefulness >= 0.80:\n",
    "        strengths.append(f\"**Actionable Recommendations** ({avg_usefulness:.0%}): Responses provide clear, actionable advice\")\n",
    "    if avg_accuracy >= 0.70:\n",
    "        strengths.append(f\"**Good Accuracy** ({avg_accuracy:.0%}): Information and recommendations are generally accurate\")\n",
    "    if avg_completeness >= 0.70:\n",
    "        strengths.append(f\"**Comprehensive Responses** ({avg_completeness:.0%}): Answers are thorough and complete\")\n",
    "    if avg_tool_appropriateness >= 0.85:\n",
    "        strengths.append(f\"**Excellent Tool Selection** ({avg_tool_appropriateness:.0%}): Agent consistently chooses appropriate tools\")\n",
    "    if avg_tool_completeness >= 0.85:\n",
    "        strengths.append(f\"**Complete Tool Usage** ({avg_tool_completeness:.0%}): Agent uses all necessary tools\")\n",
    "\n",
    "    if strengths:\n",
    "        for strength in strengths:\n",
    "            report += f\"- {strength}\\n\"\n",
    "    else:\n",
    "        report += \"- No significant strengths identified in current evaluation\\n\"\n",
    "\n",
    "    report += \"\\n### Weaknesses\\n\"\n",
    "\n",
    "    weaknesses = []\n",
    "    if avg_relevance < 0.70:\n",
    "        weaknesses.append(f\"**Low Relevance** ({avg_relevance:.0%}): Responses often miss the core question\")\n",
    "    if avg_tool_usage_score < 0.70:\n",
    "        weaknesses.append(f\"**Poor Tool Selection** ({avg_tool_usage_score:.0%}): Agent frequently uses incorrect or missing tools\")\n",
    "    if avg_usefulness < 0.70:\n",
    "        weaknesses.append(f\"**Lack of Actionability** ({avg_usefulness:.0%}): Recommendations are not sufficiently actionable\")\n",
    "    if avg_accuracy < 0.60:\n",
    "        weaknesses.append(f\"**Accuracy Issues** ({avg_accuracy:.0%}): Responses lack expected information or contain errors\")\n",
    "    if avg_completeness < 0.60:\n",
    "        weaknesses.append(f\"**Incomplete Responses** ({avg_completeness:.0%}): Answers lack necessary detail\")\n",
    "    if avg_tool_appropriateness < 0.70:\n",
    "        weaknesses.append(f\"**Poor Tool Appropriateness** ({avg_tool_appropriateness:.0%}): Agent often selects wrong or unnecessary tools\")\n",
    "    if avg_tool_completeness < 0.70:\n",
    "        weaknesses.append(f\"**Incomplete Tool Usage** ({avg_tool_completeness:.0%}): Agent frequently misses necessary tools\")\n",
    "\n",
    "    if weaknesses:\n",
    "        for weakness in weaknesses:\n",
    "            report += f\"- {weakness}\\n\"\n",
    "    else:\n",
    "        report += \"- No significant weaknesses identified in current evaluation\\n\"\n",
    "\n",
    "    # Tool Usage Analysis\n",
    "    report += \"\\n### Tool Usage Analysis\\n\"\n",
    "    all_used_tools = set()\n",
    "    all_missed_tools = set()\n",
    "    for e in evaluations:\n",
    "        all_used_tools.update(e['tool_eval']['used_tools'])\n",
    "        all_missed_tools.update(e['tool_eval']['missed_tools'])\n",
    "\n",
    "    report += f\"- **Tools Successfully Used**: {', '.join(sorted(all_used_tools)) if all_used_tools else 'None'}\\n\"\n",
    "    report += f\"- **Frequently Missed Tools**: {', '.join(sorted(all_missed_tools)) if all_missed_tools else 'None'}\\n\"\n",
    "\n",
    "    # Recommendations for Improvement\n",
    "    report += \"\\n## Recommendations for Improvement\\n\\n\"\n",
    "\n",
    "    recommendations = []\n",
    "\n",
    "    # Priority recommendations based on weaknesses\n",
    "    if avg_accuracy < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'HIGH',\n",
    "            'area': 'Response Accuracy',\n",
    "            'recommendation': 'Review and enhance the system prompt to ensure agent responses align with expected information',\n",
    "            'action': 'Update ECOHOME_SYSTEM_PROMPT with more specific examples and guidelines'\n",
    "        })\n",
    "\n",
    "    if avg_tool_usage_score < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'HIGH',\n",
    "            'area': 'Tool Selection',\n",
    "            'recommendation': 'Improve tool descriptions and add examples to help agent select appropriate tools',\n",
    "            'action': 'Review tool definitions in agent configuration and add usage examples'\n",
    "        })\n",
    "\n",
    "    if avg_usefulness < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'MEDIUM',\n",
    "            'area': 'Actionability',\n",
    "            'recommendation': 'Enhance prompts to emphasize providing specific, actionable recommendations',\n",
    "            'action': 'Add explicit instructions for action-oriented responses in system prompt'\n",
    "        })\n",
    "\n",
    "    if avg_completeness < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'MEDIUM',\n",
    "            'area': 'Response Completeness',\n",
    "            'recommendation': 'Ensure agent provides comprehensive answers covering all aspects of user questions',\n",
    "            'action': 'Add checklist in system prompt for complete responses'\n",
    "        })\n",
    "\n",
    "    if poor > num_successful_tests * 0.3:\n",
    "        recommendations.append({\n",
    "            'priority': 'HIGH',\n",
    "            'area': 'Overall Performance',\n",
    "            'recommendation': f'{poor} tests performed poorly (<50% score). Investigate failing test cases',\n",
    "            'action': 'Review individual test case results and identify common failure patterns'\n",
    "        })\n",
    "\n",
    "    # General recommendations\n",
    "    recommendations.append({\n",
    "        'priority': 'LOW',\n",
    "        'area': 'Testing Coverage',\n",
    "        'recommendation': 'Expand test cases to cover edge cases and more diverse scenarios',\n",
    "        'action': 'Add 5-10 additional test cases covering unusual or complex queries'\n",
    "    })\n",
    "\n",
    "    recommendations.append({\n",
    "        'priority': 'LOW',\n",
    "        'area': 'Continuous Improvement',\n",
    "        'recommendation': 'Implement automated evaluation pipeline for regular performance monitoring',\n",
    "        'action': 'Set up scheduled test runs and track metrics over time'\n",
    "    })\n",
    "\n",
    "    # Sort by priority\n",
    "    priority_order = {'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}\n",
    "    recommendations.sort(key=lambda x: priority_order[x['priority']])\n",
    "\n",
    "    for rec in recommendations:\n",
    "        report += f\"### {rec['priority']} Priority: {rec['area']}\\n\"\n",
    "        report += f\"**Recommendation**: {rec['recommendation']}\\n\\n\"\n",
    "        report += f\"**Action**: {rec['action']}\\n\\n\"\n",
    "\n",
    "    # Detailed Test Results\n",
    "    report += \"## Detailed Test Results\\n\\n\"\n",
    "\n",
    "    for eval_data in evaluations:\n",
    "        report += f\"### Test Case: {eval_data['test_id']}\\n\"\n",
    "        report += f\"**Question**: {eval_data['question']}\\n\\n\"\n",
    "        \n",
    "        report += f\"**Response Score**: {eval_data['response_eval']['overall_score']:.2f} | \"\n",
    "        report += f\"**Tool Usage Score**: {eval_data['tool_eval']['score']:.2f}\\n\\n\"\n",
    "        \n",
    "        report += f\"**Feedback**: {eval_data['response_eval']['feedback']}\\n\\n\"\n",
    "        \n",
    "        report += \"**Details**\\n\\n\"\n",
    "        report += f\"**Used Tools**: {', '.join(eval_data['tool_eval']['used_tools']) if eval_data['tool_eval']['used_tools'] else '[]'} | \"\n",
    "        report += f\"**Expected Tools**: {', '.join(eval_data['tool_eval']['expected_tools'])} | \"\n",
    "        report += f\"**Correct Tools**: {', '.join(eval_data['tool_eval']['correct_tools']) if eval_data['tool_eval']['correct_tools'] else '[]'} | \"\n",
    "        report += f\"**Missed Tools**: {', '.join(eval_data['tool_eval']['missed_tools']) if eval_data['tool_eval']['missed_tools'] else '[]'} | \"\n",
    "        report += f\"**Extra Tools**: {', '.join(eval_data['tool_eval']['extra_tools']) if eval_data['tool_eval']['extra_tools'] else '[]'}\\n\\n\"\n",
    "        \n",
    "        report += f\"**Tool Usage Feedback**: {eval_data['tool_eval']['feedback']}\\n\\n\"\n",
    "        \n",
    "        report += \"---\\n\\n\"\n",
    "\n",
    "    return report\n",
    "\n",
    "def _get_grade(score):\n",
    "    \"\"\"Helper function to convert score to letter grade\"\"\"\n",
    "    if score >= 0.90:\n",
    "        return \"A\"\n",
    "    elif score >= 0.80:\n",
    "        return \"B\"\n",
    "    elif score >= 0.70:\n",
    "        return \"C\"\n",
    "    elif score >= 0.60:\n",
    "        return \"D\"\n",
    "    else:\n",
    "        return \"F\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "8eeb59ba",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/markdown": [
       "# EcoHome Energy Advisor: Comprehensive Evaluation Report\n",
       "\n",
       "## Executive Summary\n",
       "\n",
       "This report evaluates the performance of the EcoHome Energy Advisor across 10 test cases (10 successful, 0 failed).\n",
       "\n",
       "## Overall Scores and Metrics\n",
       "\n",
       "### Primary Metrics\n",
       "- **Overall Score**: 64.73% (D)\n",
       "- **Average Response Quality**: 66.05%\n",
       "- **Average Tool Usage**: 61.67%\n",
       "\n",
       "### Detailed Metrics\n",
       "- **Relevance**: 100.00% - How well responses address user questions\n",
       "- **Accuracy**: 57.10% - Correctness of information and calculations\n",
       "- **Completeness**: 57.10% - Comprehensiveness of answers\n",
       "- **Usefulness**: 50.00% - Actionability of recommendations\n",
       "- **Tool Appropriateness**: 65.00% - Were the right tools selected?\n",
       "- **Tool Completeness**: 65.00% - Were all necessary tools used?\n",
       "\n",
       "### Performance Distribution\n",
       "- **Excellent (90%+)**: 1 tests\n",
       "- **Good (70-89%)**: 4 tests\n",
       "- **Fair (50-69%)**: 2 tests\n",
       "- **Poor (<50%)**: 3 tests\n",
       "\n",
       "## Strengths and Weaknesses\n",
       "\n",
       "### Strengths\n",
       "- **High Relevance** (100%): Agent consistently addresses user questions directly\n",
       "\n",
       "### Weaknesses\n",
       "- **Poor Tool Selection** (62%): Agent frequently uses incorrect or missing tools\n",
       "- **Lack of Actionability** (50%): Recommendations are not sufficiently actionable\n",
       "- **Accuracy Issues** (57%): Responses lack expected information or contain errors\n",
       "- **Incomplete Responses** (57%): Answers lack necessary detail\n",
       "- **Poor Tool Appropriateness** (65%): Agent often selects wrong or unnecessary tools\n",
       "- **Incomplete Tool Usage** (65%): Agent frequently misses necessary tools\n",
       "\n",
       "### Tool Usage Analysis\n",
       "- **Tools Successfully Used**: get_electricity_prices, get_weather_forecast, query_solar_generation, search_energy_tips\n",
       "- **Frequently Missed Tools**: search_energy_tips\n",
       "\n",
       "## Recommendations for Improvement\n",
       "\n",
       "### HIGH Priority: Response Accuracy\n",
       "**Recommendation**: Review and enhance the system prompt to ensure agent responses align with expected information\n",
       "\n",
       "**Action**: Update ECOHOME_SYSTEM_PROMPT with more specific examples and guidelines\n",
       "\n",
       "### HIGH Priority: Tool Selection\n",
       "**Recommendation**: Improve tool descriptions and add examples to help agent select appropriate tools\n",
       "\n",
       "**Action**: Review tool definitions in agent configuration and add usage examples\n",
       "\n",
       "### MEDIUM Priority: Actionability\n",
       "**Recommendation**: Enhance prompts to emphasize providing specific, actionable recommendations\n",
       "\n",
       "**Action**: Add explicit instructions for action-oriented responses in system prompt\n",
       "\n",
       "### MEDIUM Priority: Response Completeness\n",
       "**Recommendation**: Ensure agent provides comprehensive answers covering all aspects of user questions\n",
       "\n",
       "**Action**: Add checklist in system prompt for complete responses\n",
       "\n",
       "### LOW Priority: Testing Coverage\n",
       "**Recommendation**: Expand test cases to cover edge cases and more diverse scenarios\n",
       "\n",
       "**Action**: Add 5-10 additional test cases covering unusual or complex queries\n",
       "\n",
       "### LOW Priority: Continuous Improvement\n",
       "**Recommendation**: Implement automated evaluation pipeline for regular performance monitoring\n",
       "\n",
       "**Action**: Set up scheduled test runs and track metrics over time\n",
       "\n",
       "## Detailed Test Results\n",
       "\n",
       "### Test Case: ev_charging_cost\n",
       "**Question**: When is the cheapest time to charge my EV tomorrow?\n",
       "\n",
       "**Response Score**: 0.81 | **Tool Usage Score**: 1.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 8/13). Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_electricity_prices | **Expected Tools**: get_electricity_prices | **Correct Tools**: get_electricity_prices | **Missed Tools**: [] | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Perfect tool selection! All expected tools were used and no unnecessary tools were called. Correctly used: get_electricity_prices.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: ev_charging_solar\n",
       "**Question**: I want to charge my EV tomorrow using only solar power. When should I do it?\n",
       "\n",
       "**Response Score**: 0.86 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response contains 10/14 expected keywords. Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: query_solar_generation, get_weather_forecast | **Expected Tools**: get_weather_forecast | **Correct Tools**: get_weather_forecast | **Missed Tools**: [] | **Extra Tools**: query_solar_generation\n",
       "\n",
       "**Tool Usage Feedback**: Fair tool appropriateness (50%): Some incorrect tools were used. Excellent tool completeness (100%): Agent used almost all necessary tools. Correctly used: get_weather_forecast. Extra tools used: query_solar_generation.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: hvac_cost_savings\n",
       "**Question**: How can I save money on my AC bill this summer?\n",
       "\n",
       "**Response Score**: 0.41 | **Tool Usage Score**: 0.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 5/16). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast, get_electricity_prices | **Expected Tools**: search_energy_tips | **Correct Tools**: [] | **Missed Tools**: search_energy_tips | **Extra Tools**: get_weather_forecast, get_electricity_prices\n",
       "\n",
       "**Tool Usage Feedback**: Poor tool appropriateness (0%): Many incorrect or unnecessary tools were used. Poor tool completeness (0%): Many necessary tools were not used. Missed tools: search_energy_tips. Extra tools used: get_electricity_prices, get_weather_forecast.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: hvac_pre_cooling\n",
       "**Question**: There is a heatwave tomorrow. How should I set my thermostat?\n",
       "\n",
       "**Response Score**: 0.86 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response contains 10/14 expected keywords. Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast | **Expected Tools**: get_weather_forecast, search_energy_tips | **Correct Tools**: get_weather_forecast | **Missed Tools**: search_energy_tips | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Excellent tool appropriateness (100%): Agent selected the right tools. Fair tool completeness (50%): Some necessary tools were missed. Correctly used: get_weather_forecast. Missed tools: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: appliance_scheduling\n",
       "**Question**: When is the best time to run my dishwasher and washing machine?\n",
       "\n",
       "**Response Score**: 0.93 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response contains 12/14 expected keywords. Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast, get_electricity_prices | **Expected Tools**: get_electricity_prices | **Correct Tools**: get_electricity_prices | **Missed Tools**: [] | **Extra Tools**: get_weather_forecast\n",
       "\n",
       "**Tool Usage Feedback**: Fair tool appropriateness (50%): Some incorrect tools were used. Excellent tool completeness (100%): Agent used almost all necessary tools. Correctly used: get_electricity_prices. Extra tools used: get_weather_forecast.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: solar_maximization_cloudy\n",
       "**Question**: It's going to be cloudy tomorrow. How can I maximize my solar panel output?\n",
       "\n",
       "**Response Score**: 0.50 | **Tool Usage Score**: 0.50\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 7/14). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: query_solar_generation, get_weather_forecast | **Expected Tools**: get_weather_forecast, search_energy_tips | **Correct Tools**: get_weather_forecast | **Missed Tools**: search_energy_tips | **Extra Tools**: query_solar_generation\n",
       "\n",
       "**Tool Usage Feedback**: Fair tool appropriateness (50%): Some incorrect tools were used. Fair tool completeness (50%): Some necessary tools were missed. Correctly used: get_weather_forecast. Missed tools: search_energy_tips. Extra tools used: query_solar_generation.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: solar_maximization_sunny\n",
       "**Question**: It will be sunny all week. How can I make the most of my solar panels?\n",
       "\n",
       "**Response Score**: 0.57 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 7/11). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast | **Expected Tools**: get_weather_forecast, search_energy_tips | **Correct Tools**: get_weather_forecast | **Missed Tools**: search_energy_tips | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Excellent tool appropriateness (100%): Agent selected the right tools. Fair tool completeness (50%): Some necessary tools were missed. Correctly used: get_weather_forecast. Missed tools: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: general_energy_savings\n",
       "**Question**: What are some general tips for saving energy at home?\n",
       "\n",
       "**Response Score**: 0.46 | **Tool Usage Score**: 1.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 7/17). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: search_energy_tips | **Expected Tools**: search_energy_tips | **Correct Tools**: search_energy_tips | **Missed Tools**: [] | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Perfect tool selection! All expected tools were used and no unnecessary tools were called. Correctly used: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: device_best_practices\n",
       "**Question**: What are the best practices for using my refrigerator efficiently?\n",
       "\n",
       "**Response Score**: 0.43 | **Tool Usage Score**: 1.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 5/14). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: search_energy_tips | **Expected Tools**: search_energy_tips | **Correct Tools**: search_energy_tips | **Missed Tools**: [] | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Perfect tool selection! All expected tools were used and no unnecessary tools were called. Correctly used: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: seasonal_energy_management\n",
       "**Question**: How should my energy habits change from winter to summer?\n",
       "\n",
       "**Response Score**: 0.80 | **Tool Usage Score**: 0.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 13/22). Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: [] | **Expected Tools**: search_energy_tips | **Correct Tools**: [] | **Missed Tools**: search_energy_tips | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Poor tool appropriateness (0%): Many incorrect or unnecessary tools were used. Poor tool completeness (0%): Many necessary tools were not used. Missed tools: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n"
      ],
      "text/plain": [
       "<IPython.core.display.Markdown object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from IPython.display import display, Markdown\n",
    "\n",
    "def display_evaluation_report(report):\n",
    "    \"\"\"Displays the evaluation report in Markdown format.\"\"\"\n",
    "    display(Markdown(report))\n",
    "\n",
    "report = generate_evaluation_report(test_results)\n",
    "display_evaluation_report(report)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
</file_content>

<file_content path="PLAYBOOK_failure_aggregation.md">
# ð Failure Aggregation Playbook

> **Purpose**: Replicable workflow to extract anti-patterns from student feedback and generate visual learning guides.

---

## ð¯ Goal

Transform scattered student feedback files into a consolidated, slide-ready visual guide that documents common mistakes ("anti-patterns") for educational purposes.

---

## ð Prerequisites

```
project/
âââ tmp/
â   âââ archive/          # Past student submissions
â   â   âââ stu_100/
â   â   â   âââ feedback/
â   â   â       âââ 1.md  # Criterion 1 feedback
â   â   â       âââ 2.md
â   â   â       âââ ...
â   â   âââ stu_N/
â   âââ stu_current/      # Current student
âââ my_submission/        # Output directory
```

---

## ð Pipeline Steps

### Step 1: Generate Failures List

```bash
cd project/
grep -r -l "Status:.*FAIL\|Status:.*NOT MET" tmp/ > my_submission/failures_list.txt
```

This creates a list of all files containing failure feedback.

---

### Step 2: Run Aggregation Script

```bash
cd my_submission/
python3 aggregate_failures.py
```

**Outputs**:
- `visual_antipatterns_guide.md` - Slide-ready visual guide
- Console: Statistics on files processed

---

### Step 3: Review & Iterate

Open `visual_antipatterns_guide.md` and verify:
- [ ] Executive summary has correct counts
- [ ] Mermaid mindmap renders properly
- [ ] Before/After code examples are accurate
- [ ] Visual metaphors make sense

---

## ð ï¸ Script Customization

### Adding New Categories

Edit `ANTIPATTERN_CATEGORIES` in `aggregate_failures.py`:

```python
ANTIPATTERN_CATEGORIES = {
    "your_category": {
        "title": "ð·ï¸ Category Title",
        "icon": "ð´",
        "description": "What this category covers",
        "keywords": ["keyword1", "keyword2"]  # For auto-categorization
    }
}
```

### Adding Fix Suggestions

Add to `generate_fix_suggestion()`:

```python
"your_category": '''```python
# â CORRECT: Example fix
...
```'''
```

### Adding Visual Metaphors

Add to `metaphors` dict in `generate_visual_guide()`:

```python
"your_category": "Like [relatable analogy]..."
```

---

## ð Output Structure

```markdown
# ð« Agent Anti-Patterns Visual Guide

## ð Executive Summary
- Total failures table with impact levels

## ðºï¸ Anti-Pattern Landscape
- Mermaid mindmap diagram

## Category Sections
- ð Frequency Distribution (bar chart)
- ð Top Anti-Patterns (detailed cards)
  - Impact badge
  - What went wrong
  - Why it fails
  - â Bad code
  - â Correct pattern
  - ð¡ Visual metaphor

## ð¨ Slide Generation Hints
- Tips for LLM slide creation
```

---

## ð Replication Checklist

For a new project:

1. [ ] Copy `aggregate_failures.py` to new project's output directory
2. [ ] Update `OUTPUT_FILE` and `FAILURES_LIST` paths in script
3. [ ] Customize `ANTIPATTERN_CATEGORIES` for project-specific issues
4. [ ] Run grep to generate `failures_list.txt`
5. [ ] Run `python3 aggregate_failures.py`
6. [ ] Review and adjust extraction regex if needed

---

## âï¸ Extraction Strategies (in order)

The script tries multiple patterns to extract failure reasons:

1. **Action Items format**: `1. **Title**: **Issue**: ...`
2. **Critical Requirement NOT Met**: Explicit failure headers
3. **(PARTIAL)/(FAIL) sections**: Section-level status markers
4. **Required Fix sections**: Explicit fix instructions
5. **Assessment + "However"**: Prose with contrasting feedback
6. **Status: FAIL reason**: Generic fallback

If extraction is low, check which format your feedback uses and add a new strategy.

---

## ð Metrics

| Metric | This Run |
|--------|----------|
| Files Scanned | 1488 |
| Failures Extracted | 68 |
| Categories Identified | 4 |
| Total Issues | 73 |

---

## ð Use Cases

1. **Student Education**: Generate slides showing common mistakes
2. **Reviewer Training**: Document anti-patterns for consistency
3. **Rubric Improvement**: Identify frequently failed criteria
4. **AI Feedback**: Feed to LLM for generating tailored feedback
</file_content>

<file_content path="README.md">
# EcoHome Energy Advisor

An AI-powered energy optimization agent that helps customers reduce electricity costs and environmental impact through personalized recommendations.

## Project Overview

EcoHome is a smart-home energy start-up that helps customers with solar panels, electric vehicles, and smart thermostats optimize their energy usage. The Energy Advisor agent provides personalized recommendations about when to run devices to minimize costs and carbon footprint.

### Key Features

- **Weather Integration**: Uses weather forecasts to predict solar generation
- **Dynamic Pricing**: Considers time-of-day electricity prices for cost optimization
- **Historical Analysis**: Queries past energy usage patterns for personalized advice
- **RAG Pipeline**: Retrieves relevant energy-saving tips and best practices
- **Multi-device Optimization**: Handles EVs, HVAC, appliances, and solar systems
- **Cost Calculations**: Provides specific savings estimates and ROI analysis

## Project Structure

```
ecohome_starter/
âââ models/
â   âââ __init__.py
â   âââ energy.py              # Database models for energy data
âââ data/
â   âââ documents/
â       âââ tip_device_best_practices.txt
â       âââ tip_energy_savings.txt
âââ agent.py                   # Main Energy Advisor agent
âââ tools.py                   # Agent tools (weather, pricing, database, RAG)
âââ requirements.txt           # Python dependencies
âââ 01_db_setup.ipynb         # Database setup and sample data
âââ 02_rag_setup.ipynb        # RAG pipeline setup
âââ 03_agent_evaluation.ipynb # Agent testing and evaluation
âââ 04_agent_run.ipynb        # Running the agent with examples
âââ README.md                  # This file
```

## Setup Instructions

### 1. Install Dependencies

```bash
pip install -r requirements.txt
```

### 2. Set Environment Variables

### Python Version

This project was developed and tested with Python 3.10.18.

Create a `.env` file with your API keys:

```bash
VOCAREUM_API_KEY=your_vocareum_api_key_here
OPENAI_API_KEY=your_openai_api_key_here
```

### 3. Run the Notebooks

Execute the notebooks in order:

1. **01_db_setup.ipynb** - Set up the database and populate with sample data
2. **02_rag_setup.ipynb** - Configure the RAG pipeline for energy tips
3. **03_run_and_evaluate.ipynb** - Test and evaluate the agent with comprehensive test cases

## Agent Capabilities

### Tools Available

- **Weather Forecast**: Get hourly weather predictions and solar irradiance
- **Electricity Pricing**: Access time-of-day pricing data
- **Energy Usage Query**: Retrieve historical consumption data
- **Solar Generation Query**: Get past solar production data
- **Energy Tips Search**: Find relevant energy-saving recommendations
- **Savings Calculator**: Compute potential cost savings

### Example Questions

The Energy Advisor can answer questions like:

- "When should I charge my electric car tomorrow to minimize cost and maximize solar power?"
- "What temperature should I set my thermostat on Wednesday afternoon if electricity prices spike?"
- "Suggest three ways I can reduce energy use based on my usage history."
- "How much can I save by running my dishwasher during off-peak hours?"

## Database Schema

### Energy Usage Table
- `timestamp`: When the energy was consumed
- `consumption_kwh`: Amount of energy used
- `device_type`: Type of device (EV, HVAC, appliance)
- `device_name`: Specific device name
- `cost_usd`: Cost at time of usage

### Solar Generation Table
- `timestamp`: When the energy was generated
- `generation_kwh`: Amount of solar energy produced
- `weather_condition`: Weather during generation
- `temperature_c`: Temperature at time of generation
- `solar_irradiance`: Solar irradiance level

## Learning Objectives

This project helps students learn:

1. **Database Design**: Creating schemas for energy management systems
2. **API Integration**: Working with external weather and pricing APIs
3. **RAG Implementation**: Building retrieval-augmented generation pipelines
4. **Agent Development**: Creating intelligent agents with tool usage
5. **Evaluation Methods**: Testing and measuring agent performance
6. **Energy Optimization**: Understanding smart home energy management

## Key Technologies

- **LangChain**: Agent framework and tool integration
- **LangGraph**: Agent orchestration and workflow
- **ChromaDB**: Vector database for document retrieval
- **SQLAlchemy**: Database ORM and management
- **OpenAI**: LLM and embeddings
- **SQLite**: Local database storage

## Evaluation Criteria

The agent is evaluated on:

- **Accuracy**: Correct information and calculations
- **Relevance**: Responses address the user's question
- **Completeness**: Comprehensive answers with actionable advice
- **Tool Usage**: Appropriate use of available tools
- **Reasoning**: Clear explanation of recommendations

## Getting Started

1. Clone this repository
2. Install the required dependencies
3. Set up your environment variables
4. Run the notebooks in sequence
5. Test the agent with your own questions

## Contributing

This is a learning project. Feel free to:
- Add new tools and capabilities
- Improve the evaluation metrics
- Enhance the RAG pipeline
- Add more sophisticated optimization algorithms

## License

This project is for educational purposes as part of the Udacity Course 2 curriculum.
</file_content>

<file_content path="agent.py">
import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage
from langgraph.prebuilt import create_react_agent
from tools import TOOL_KIT

load_dotenv()


class Agent:
    def __init__(self, instructions:str, model:str="gpt-4o-mini"):

        # Initialize the LLM
        llm = ChatOpenAI(
            model=model,
            temperature=0.0,
            base_url="https://openai.vocareum.com/v1",
            api_key=os.getenv("VOCAREUM_API_KEY")
        )

        # Create the Energy Advisor agent
        self.graph = create_react_agent(
            name="energy_advisor",
            prompt=SystemMessage(content=instructions),
            model=llm,
            tools=TOOL_KIT,
        )

    def invoke(self, question: str, context:str=None) -> str:
        """
        Ask the Energy Advisor a question about energy optimization.
        
        Args:
            question (str): The user's question about energy optimization
            location (str): Location for weather and pricing data
        
        Returns:
            str: The advisor's response with recommendations
        """
        
        messages = []
        if context:
            # Add some context to the question as a system message
            messages.append(
                ("system", context)
            )

        messages.append(
            ("user", question)
        )
        
        # Get response from the agent
        response = self.graph.invoke(
            input= {
                "messages": messages
            }
        )
        
        return response

    def get_agent_tools(self):
        """Get list of available tools for the Energy Advisor"""
        return [t.name for t in TOOL_KIT]
</file_content>

<file_content path="aggregate_failures.py">
#!/usr/bin/env python3
"""
Visual Anti-Patterns Guide Generator

This script processes student feedback files and generates a rich, 
infographic-ready markdown document for LLM slide generation.
"""

import os
import re
from collections import defaultdict
from dataclasses import dataclass, field
from typing import List, Dict, Optional

OUTPUT_FILE = "/Users/sharad/Projects/udacity-reviews-hq/projects/energy-advisor/my_submission/visual_antipatterns_guide.md"
FAILURES_LIST = "/Users/sharad/Projects/udacity-reviews-hq/projects/energy-advisor/my_submission/failures_list.txt"

# Define anti-pattern categories with visual metadata
ANTIPATTERN_CATEGORIES = {
    "string_matching": {
        "title": "ð¤ String Matching Pitfalls",
        "icon": "â ï¸",
        "color": "red",
        "description": "Logic errors where substring matching causes false positives/negatives",
        "keywords": ["substring", "in ", "contains", "COMPAT", "matching", "parsing logic"]
    },
    "missing_documentation": {
        "title": "ð Missing Documentation",
        "icon": "ð",
        "color": "orange",
        "description": "Tool docstrings lacking critical information for LLM understanding",
        "keywords": ["docstring", "documentation", "missing", "placeholder", "fill in", "date format", "YYYY-MM-DD"]
    },
    "output_format_mismatch": {
        "title": "ð¤ Output Format Mismatch",
        "icon": "ð",
        "color": "yellow",
        "description": "Response formats that don't match downstream parser expectations",
        "keywords": ["format", "output", "IS_COMPATIBLE", "mismatch", "parser", "JSON", "Pydantic", "validation error"]
    },
    "hallucination_triggers": {
        "title": "ð«ï¸ Hallucination Triggers",
        "icon": "ð»",
        "color": "purple",
        "description": "Prompt patterns that cause LLMs to generate fictional data",
        "keywords": ["hallucinate", "placeholder", "fictional", "doesn't exist", "made up", "invented", "fake"]
    },
    "incomplete_react_cycle": {
        "title": "ð Incomplete ReAct Cycle",
        "icon": "ð",
        "color": "blue",
        "description": "Missing THINK-ACT-OBSERVE components in agent prompts",
        "keywords": ["ReAct", "THINK", "ACT", "OBSERVE", "cycle", "tool", "parameter", "argument", "schema", "exit"]
    },
    "missing_constraints": {
        "title": "ð§ Missing Constraints",
        "icon": "ð",
        "color": "gray",
        "description": "Prompts lacking explicit boundaries or validation rules",
        "keywords": ["constraint", "validation", "boundary", "explicit", "requirement", "backup", "alternative", "contingency", "option"]
    },
    "role_definition": {
        "title": "ð­ Role Definition Issues",
        "icon": "ð­",
        "color": "teal",
        "description": "Missing or unclear role instructions for the LLM agent",
        "keywords": ["role", "identity", "persona", "analyst", "expert", "agent"]
    },
    "chain_of_thought": {
        "title": "ð§  Chain-of-Thought Gaps",
        "icon": "ð§ ",
        "color": "pink",
        "description": "Missing step-by-step reasoning guidance in prompts",
        "keywords": ["chain-of-thought", "reasoning", "step-by-step", "analysis", "think through", "CoT"]
    }
}


@dataclass
class AntiPattern:
    """Represents a single anti-pattern instance"""
    category: str
    title: str
    description: str
    bad_code: Optional[str] = None
    good_code: Optional[str] = None
    why_fails: str = ""
    frequency: int = 0
    students: List[str] = field(default_factory=list)
    criterion: str = ""

def categorize_issue(issue_text: str, full_text: str) -> str:
    """Categorize an issue based on keywords"""
    combined = (issue_text + " " + full_text).lower()
    
    for cat_id, cat_info in ANTIPATTERN_CATEGORIES.items():
        for keyword in cat_info["keywords"]:
            if keyword.lower() in combined:
                return cat_id
    
    return "other"

def extract_code_blocks(text: str) -> List[str]:
    """Extract all code blocks from text"""
    return re.findall(r"```[\w]*\n?(.*?)```", text, re.DOTALL)

def generate_fix_suggestion(category: str, bad_code: str) -> str:
    """Generate a suggested fix based on category"""
    fixes = {
        "string_matching": '''```python
# â CORRECT: Check for negative case first
if "INCOMPAT" in normalized_resp:
    is_compatible = False
elif "COMPAT" in normalized_resp:
    is_compatible = True

# â BETTER: Use exact matching
if normalized_resp == "IS_COMPATIBLE":
    is_compatible = True
elif normalized_resp == "IS_INCOMPATIBLE":
    is_compatible = False
```''',
        "missing_documentation": '''```python
# â CORRECT: Comprehensive docstring with format specification
def get_activities_by_date_tool(date: str, city: str) -> List[Activity]:
    """Retrieves available activities for a specific date and city.
    
    Args:
        date (str): Target date in YYYY-MM-DD format (e.g., "2025-06-12")
        city (str): City name (e.g., "AgentsVille")
    
    Returns:
        List[Activity]: Available activities matching criteria
    
    Example:
        >>> get_activities_by_date_tool("2025-06-12", "AgentsVille")
        [Activity(id="A001", name="Museum Tour", ...)]
    """
```''',
        "output_format_mismatch": '''```yaml
# â CORRECT: Match the exact expected format from rubric
OUTPUT_FORMAT:
  - Use "IS_COMPATIBLE" (not "COMPATIBLE")
  - Use "IS_INCOMPATIBLE" (not "INCOMPATIBLE")
  
EXAMPLES:
  - Input: "Outdoor hiking" + "Heavy Rain"
    Output: "IS_INCOMPATIBLE: Heavy rain makes trails dangerous"
```''',
        "incomplete_react_cycle": '''```python
# â CORRECT: Complete ReAct prompt with all components
ITINERARY_REVISION_AGENT_SYSTEM_PROMPT = """
You are an expert travel planner. Follow the THINK-ACT-OBSERVE cycle:

## Available Tools (with parameter schemas)
- get_activities_by_date_tool(date: str, city: str): Get activities
  - date: Date in YYYY-MM-DD format
  - city: City name string
- run_evals_tool(travel_plan: TravelPlan, info: VacationInfo): Validate plan
- final_answer_tool(answer: str): Submit final answer and EXIT

## Workflow
1. THINK: Analyze what needs to be done
2. ACT: Call a tool with proper JSON: {"tool_name": "...", "arguments": {...}}
3. OBSERVE: Review the result
4. Repeat until ready, then call final_answer_tool to EXIT
"""
```''',
        "missing_constraints": '''```python
# â CORRECT: Include backup options in weather compatibility prompt
WEATHER_COMPATIBILITY_PROMPT = """
## Task
- Report IS_COMPATIBLE if weather allows the activity
- Report IS_INCOMPATIBLE if weather prevents the activity
- Consider backup options: Can the activity move indoors?
- Consider alternatives: Are there covered areas available?

## Decision Criteria
- Indoor activities: Generally IS_COMPATIBLE
- Outdoor with backup: Consider the backup option
- Outdoor-only in bad weather: IS_INCOMPATIBLE
"""
```''',
        "role_definition": '''```python
# â CORRECT: Clear role definition with responsibilities
SYSTEM_PROMPT = """
You are an expert travel planning agent specializing in outdoor activities.

Your responsibilities:
1. Create weather-appropriate itineraries
2. Ensure budget compliance
3. Maximize activity variety
4. Consider traveler preferences

Your expertise includes: activity scheduling, weather analysis, backup planning.
"""
```''',
        "chain_of_thought": '''```python
# â CORRECT: Explicit Chain-of-Thought guidance
PROMPT = """
## Analysis Process (follow these steps)
1. First, review all available activities and their requirements
2. Then, check weather conditions for each date
3. Next, filter activities by weather compatibility
4. Finally, select activities that maximize variety while staying in budget

Show your reasoning at each step before making decisions.
"""
```'''
    }
    return fixes.get(category, "")


def process_failures() -> Dict[str, List[AntiPattern]]:
    """Process all failure files and extract anti-patterns"""
    
    patterns_by_category: Dict[str, List[AntiPattern]] = defaultdict(list)
    issue_tracker: Dict[str, AntiPattern] = {}  # Dedupe by issue text
    
    print("Reading failure list...")
    try:
        with open(FAILURES_LIST, "r") as f:
            file_list = [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        print("failures_list.txt not found.")
        return {}
    
    print(f"Processing {len(file_list)} files...")
    processed = 0
    
    for fb_path in file_list:
        if "summary.md" in fb_path or "criteria_prompts" in fb_path:
            continue
            
        # Extract metadata from path
        stu_match = re.search(r"(stu_\d+)", fb_path)
        stu_id = stu_match.group(1) if stu_match else "unknown"
        
        filename = os.path.basename(fb_path)
        crit_match = re.search(r"(\d+)", filename)
        crit_id = crit_match.group(1) if crit_match else "unknown"
        
        try:
            with open(fb_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            
            if not re.search(r"Status:.*(?:FAIL|NOT MET)", content, re.IGNORECASE):
                continue
            
            found_issue = False
            code_blocks = extract_code_blocks(content)
            bad_code = code_blocks[0] if code_blocks else ""
                
            # Strategy 1: Action Items with Issue/Why/Fix (stu_333 format)
            action_items = re.findall(
                r"\d+\.\s+\*\*([^*]+)\*\*:.*?\*\*Issue\*\*:\s*(.*?)(?=\*\*(?:Why|Fix)|$)",
                content, re.DOTALL
            )
            
            for title, issue in action_items:
                title = title.strip()
                issue = issue.strip()
                
                why_match = re.search(
                    rf"{re.escape(title)}.*?\*\*Why it (?:fails|matters)\*\*:\s*(.*?)(?=\*\*Fix|$)",
                    content, re.DOTALL
                )
                why = why_match.group(1).strip() if why_match else ""
                
                category = categorize_issue(issue, content)
                issue_key = issue[:100]
                
                if issue_key in issue_tracker:
                    issue_tracker[issue_key].frequency += 1
                    issue_tracker[issue_key].students.append(stu_id)
                else:
                    pattern = AntiPattern(
                        category=category,
                        title=title,
                        description=issue,
                        bad_code=bad_code,
                        why_fails=why,
                        frequency=1,
                        students=[stu_id],
                        criterion=crit_id
                    )
                    issue_tracker[issue_key] = pattern
                found_issue = True
            
            # Strategy 2: "Critical Requirement NOT Met" sections (stu_139 format)
            if not found_issue:
                critical_match = re.search(
                    r"\*\*Critical Requirement NOT Met:\*\*.*?[-â¢]\s*\*\*([^*]+)\*\*[:\s]*(.*?)(?=\n\n|\*\*Required Fix|$)",
                    content, re.DOTALL
                )
                if critical_match:
                    title = critical_match.group(1).strip()
                    issue = critical_match.group(2).strip()
                    
                    # Get detailed explanation
                    why = ""
                    why_match = re.search(r"The rubric.*?states[:\s]*(.*?)(?=\n\n|$)", content, re.DOTALL)
                    if why_match:
                        why = why_match.group(1).strip()
                    
                    category = categorize_issue(title + " " + issue, content)
                    issue_key = (title + issue)[:100]
                    
                    if issue_key in issue_tracker:
                        issue_tracker[issue_key].frequency += 1
                        issue_tracker[issue_key].students.append(stu_id)
                    else:
                        pattern = AntiPattern(
                            category=category,
                            title=title,
                            description=issue,
                            bad_code=bad_code,
                            why_fails=why,
                            frequency=1,
                            students=[stu_id],
                            criterion=crit_id
                        )
                        issue_tracker[issue_key] = pattern
                    found_issue = True
            
            # Strategy 3: "(PARTIAL)" or "(FAIL)" section headers
            if not found_issue:
                partial_matches = re.findall(
                    r"###\s*\d*\.?\s*([^(]+)\s*\((?:PARTIAL|FAIL)\)(.*?)(?=###|\Z)",
                    content, re.DOTALL
                )
                for title, section in partial_matches:
                    title = title.strip()
                    # Find the issue in this section
                    finding_match = re.search(r"\*\*Finding:\*\*\s*(.*?)(?=\*\*Analysis|$)", section, re.DOTALL)
                    analysis_match = re.search(r"\*\*Analysis:\*\*\s*(.*?)(?=\n\n|$)", section, re.DOTALL)
                    
                    issue = finding_match.group(1).strip() if finding_match else title
                    why = analysis_match.group(1).strip() if analysis_match else ""
                    
                    category = categorize_issue(title + issue, content)
                    issue_key = (title + issue[:50])[:100]
                    
                    if issue_key in issue_tracker:
                        issue_tracker[issue_key].frequency += 1
                        issue_tracker[issue_key].students.append(stu_id)
                    else:
                        pattern = AntiPattern(
                            category=category,
                            title=title,
                            description=issue[:200],
                            bad_code=bad_code,
                            why_fails=why[:300],
                            frequency=1,
                            students=[stu_id],
                            criterion=crit_id
                        )
                        issue_tracker[issue_key] = pattern
                    found_issue = True
            
            # Strategy 4: "Required Fix" section
            if not found_issue:
                fix_match = re.search(
                    r"\*\*Required Fix:\*\*\s*(.*?)(?=```|$)",
                    content, re.DOTALL
                )
                if fix_match:
                    issue = fix_match.group(1).strip()
                    category = categorize_issue(issue, content)
                    issue_key = issue[:100]
                    
                    if issue_key in issue_tracker:
                        issue_tracker[issue_key].frequency += 1
                        issue_tracker[issue_key].students.append(stu_id)
                    else:
                        pattern = AntiPattern(
                            category=category,
                            title="Required Fix",
                            description=issue[:200],
                            bad_code=bad_code,
                            why_fails="",
                            frequency=1,
                            students=[stu_id],
                            criterion=crit_id
                        )
                        issue_tracker[issue_key] = pattern
                    found_issue = True
            
            # Strategy 5: Assessment section with "However" (fallback)
            if not found_issue:
                assessment = re.search(r"## Assessment(.*?)(?=## |\Z)", content, re.DOTALL)
                if assessment:
                    text = assessment.group(1).strip()
                    however_match = re.search(r"However,?\s*(.*?)(?=\n\n|$)", text, re.DOTALL)
                    if however_match:
                        issue = however_match.group(1).strip()
                        category = categorize_issue(issue, text)
                        issue_key = issue[:100]
                        
                        if issue_key in issue_tracker:
                            issue_tracker[issue_key].frequency += 1
                            issue_tracker[issue_key].students.append(stu_id)
                        else:
                            pattern = AntiPattern(
                                category=category,
                                title="Assessment Issue",
                                description=issue,
                                why_fails=text[:500],
                                frequency=1,
                                students=[stu_id],
                                criterion=crit_id
                            )
                            issue_tracker[issue_key] = pattern
                        found_issue = True
            
            # Strategy 6: Generic "Status: FAIL" reason extraction
            if not found_issue:
                # Look for text after "Status: FAIL" header
                fail_reason = re.search(
                    r"##\s*Status:\s*FAIL\s*(.*?)(?=\n##|\Z)",
                    content, re.DOTALL | re.IGNORECASE
                )
                if fail_reason:
                    text = fail_reason.group(1).strip()
                    # First sentence or first 200 chars
                    issue = text.split('.')[0] if '.' in text[:200] else text[:200]
                    category = categorize_issue(issue, text)
                    issue_key = issue[:100]
                    
                    if issue_key in issue_tracker:
                        issue_tracker[issue_key].frequency += 1
                        issue_tracker[issue_key].students.append(stu_id)
                    else:
                        pattern = AntiPattern(
                            category=category,
                            title="Failure Reason",
                            description=issue,
                            bad_code=bad_code,
                            why_fails=text[:300],
                            frequency=1,
                            students=[stu_id],
                            criterion=crit_id
                        )
                        issue_tracker[issue_key] = pattern
                    found_issue = True
            
            if found_issue:
                processed += 1
                            
        except Exception as e:
            print(f"Error: {fb_path}: {e}")
    
    print(f"Extracted issues from {processed} files")
    
    # Organize by category
    for pattern in issue_tracker.values():
        patterns_by_category[pattern.category].append(pattern)
    
    # Sort each category by frequency
    for cat in patterns_by_category:
        patterns_by_category[cat].sort(key=lambda x: x.frequency, reverse=True)
    
    return patterns_by_category


def generate_visual_guide(patterns: Dict[str, List[AntiPattern]]):
    """Generate the visual markdown guide"""
    
    total_failures = sum(p.frequency for cat in patterns.values() for p in cat)
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        # Header
        out.write("# ð« Agent Anti-Patterns Visual Guide\n\n")
        out.write("> **Purpose**: A visual reference for LLMs to generate educational slides and infographics about common agent development mistakes.\n\n")
        
        # Executive Summary
        out.write("## ð Executive Summary\n\n")
        out.write(f"**Total Failures Analyzed**: {total_failures}\n\n")
        
        # Statistics table
        out.write("| Category | Count | Impact Level |\n")
        out.write("|----------|-------|-------------|\n")
        for cat_id, cat_patterns in sorted(patterns.items(), key=lambda x: sum(p.frequency for p in x[1]), reverse=True):
            if cat_id == "other":
                continue
            cat_info = ANTIPATTERN_CATEGORIES.get(cat_id, {"title": cat_id, "icon": "â"})
            count = sum(p.frequency for p in cat_patterns)
            impact = "ð´ Critical" if count > 100 else "ð¡ Moderate" if count > 20 else "ð¢ Low"
            out.write(f"| {cat_info['icon']} {cat_info['title']} | {count} | {impact} |\n")
        out.write("\n")
        
        # Visual Overview Diagram
        out.write("## ðºï¸ Anti-Pattern Landscape\n\n")
        out.write("```mermaid\nmindmap\n")
        out.write("  root((Agent\\nAnti-Patterns))\n")
        for cat_id, cat_patterns in patterns.items():
            if cat_id == "other" or not cat_patterns:
                continue
            cat_info = ANTIPATTERN_CATEGORIES.get(cat_id, {"title": cat_id})
            safe_title = cat_info['title'].replace('"', "'")
            out.write(f"    {safe_title}\n")
            for p in cat_patterns[:3]:  # Top 3 issues per category
                safe_desc = p.description[:30].replace('"', "'").replace("\n", " ")
                out.write(f"      {safe_desc}...\n")
        out.write("```\n\n")
        
        # Detailed Sections per Category
        for cat_id, cat_patterns in patterns.items():
            if cat_id == "other" or not cat_patterns:
                continue
                
            cat_info = ANTIPATTERN_CATEGORIES.get(cat_id, {"title": cat_id, "icon": "â", "description": ""})
            
            out.write(f"---\n\n## {cat_info['icon']} {cat_info['title']}\n\n")
            out.write(f"> {cat_info['description']}\n\n")
            
            # Frequency chart (text-based)
            out.write("### ð Frequency Distribution\n\n")
            out.write("```\n")
            max_freq = max(p.frequency for p in cat_patterns[:5])
            for p in cat_patterns[:5]:
                bar_len = int((p.frequency / max_freq) * 30) if max_freq > 0 else 0
                bar = "â" * bar_len
                label = p.description[:40].replace("\n", " ")
                out.write(f"{label:<40} {bar} ({p.frequency})\n")
            out.write("```\n\n")
            
            # Top anti-patterns with visual cards
            out.write("### ð Top Anti-Patterns\n\n")
            
            for i, pattern in enumerate(cat_patterns[:3], 1):
                out.write(f"#### {i}. {pattern.title if pattern.title != 'Assessment Issue' else pattern.description[:50]}\n\n")
                
                # Impact badge
                impact_emoji = "ð´" if pattern.frequency > 50 else "ð¡" if pattern.frequency > 10 else "ð¢"
                out.write(f"**Impact**: {impact_emoji} {pattern.frequency} students affected (Criterion {pattern.criterion})\n\n")
                
                # Description
                if pattern.description:
                    out.write(f"**What went wrong**:\n> {pattern.description}\n\n")
                
                # Why it fails
                if pattern.why_fails:
                    out.write(f"**Why this breaks the agent**:\n> {pattern.why_fails[:300]}{'...' if len(pattern.why_fails) > 300 else ''}\n\n")
                
                # Bad code example
                if pattern.bad_code:
                    out.write("**â Anti-Pattern Code**:\n")
                    out.write(f"```python\n{pattern.bad_code}\n```\n\n")
                
                # Good code suggestion
                fix = generate_fix_suggestion(cat_id, pattern.bad_code or "")
                if fix:
                    out.write("**â Correct Pattern**:\n")
                    out.write(f"{fix}\n\n")
                
                # Visual metaphor
                out.write("**ð¡ Visual Metaphor**:\n")
                metaphors = {
                    "string_matching": "Like a bouncer checking IDs who lets in anyone whose name *contains* 'VIP' - including 'NOT_VIP'!",
                    "missing_documentation": "Like giving someone a map with no labels - they'll guess where to go and probably get lost.",
                    "output_format_mismatch": "Like speaking French to a Spanish parser - technically language, but nothing gets through.",
                    "hallucination_triggers": "Like asking 'describe the elephant in the room' when there's no elephant - the LLM will invent one!",
                    "incomplete_react_cycle": "Like a pilot with only 2 of 3 controls - take-off works, but landing is unpredictable.",
                    "missing_constraints": "Like asking a chef to 'make something good' with no ingredient list - they'll improvise with whatever they imagine.",
                    "role_definition": "Like hiring an actor but never telling them what character to play - expect improvised chaos.",
                    "chain_of_thought": "Like asking someone to solve a puzzle blindfolded - they might get lucky, but probably won't."
                }
                out.write(f"> {metaphors.get(cat_id, 'Every small gap compounds into system failure.')}\n\n")
                
                out.write("---\n\n")
        
        # Footer with slide generation hints
        out.write("## ð¨ Slide Generation Hints\n\n")
        out.write("When generating slides from this document:\n\n")
        out.write("1. **Title Slide**: Use the executive summary statistics\n")
        out.write("2. **Category Slides**: One slide per category with the mindmap subsection\n")
        out.write("3. **Deep Dive Slides**: Before/After code comparisons with visual metaphors\n")
        out.write("4. **Impact Slides**: Use frequency bars to show which issues are most common\n")
        out.write("5. **Takeaway Slide**: Summarize the top 3 anti-patterns to avoid\n\n")
        
        out.write("### Color Coding Reference\n\n")
        out.write("| Color | Meaning |\n")
        out.write("|-------|--------|\n")
        out.write("| ð´ Red | Critical issue (>100 occurrences) |\n")
        out.write("| ð¡ Yellow | Moderate issue (20-100 occurrences) |\n")
        out.write("| ð¢ Green | Low frequency (<20 occurrences) |\n")
    
    print(f"Done. Visual guide written to {OUTPUT_FILE}")

def main():
    patterns = process_failures()
    generate_visual_guide(patterns)
    
if __name__ == "__main__":
    main()
</file_content>

<file_content path="failures_list.txt">
/Users/sharad/Projects/udacity-reviews-hq/projects/energy-advisor/tmp/archive/stu_21/feedback/8.md
/Users/sharad/Projects/udacity-reviews-hq/projects/energy-advisor/tmp/archive/stu_21/feedback/6.md
</file_content>

<file_content path="master_failed_context.md">
# ð Master Failed Context: Energy Advisor Project

> **Generated**: 2025-12-19  
> **Project**: Energy Advisor (Udacity)  
> **Files Analyzed**: 2 sample failure feedback files  
> **Method**: LLM-based semantic extraction

---

## ð Executive Summary

| Criterion | Failures | Primary Anti-Pattern |
|-----------|----------|---------------------|
| **Criterion 8: Workflow** | ~50% | Empty tool usage / Agent hallucinating instead of acting |
| **Criterion 6: Instructions** | ~50% | Missing few-shot examples in system prompt |

---

## ð´ Workflow Anti-Patterns

### 8.1 Ghost Tool Usage (Hallucination)
**What Went Wrong**: Agent generates text responses *pretending* to have data, but logs show `tools_used: []`. The model ignores tools and hallucinates generic advice.

**Why It Matters in Real World**:
- "Financial Harm": Advising energy usage based on guessed prices/weather is dangerous
- Architecture Failure: If the agent doesn't call tools, it's just a chatbot, not an agent
- Verification: Without logs proving tool execution, the system is untrustworthy

**Rubric Requirement**: "Demonstrate end-to-end workflow with real-time data retrieval"

```python
# â ANTI-PATTERN
# Agent configured but tools not bound or ignored
agent_executor = AgentExecutor(agent=agent, tools=[]) # Tools missing!

# Logs show:
# "tools_used": []
# "response": "The current price is high..." (Hallucinated)
```

---

## ð¡ Prompt Engineering Anti-Patterns

### 6.1 Missing Few-Shot Examples
**What Went Wrong**: System prompt contains instructions ("You are...", "Do this...") but zero examples of *how* to interact.

**Why It Matters in Real World**:
- "Grounding": Examples are the specific mechanism to teach models *when* to call tools
- Reliability: Without examples, models guess the format and often skip steps
- Industry Standard: Few-shot prompting is standard practice for robust systems

**Rubric Requirement**: "Include example questions (few-shot prompting) in system instructions"

---

## ð¯ Top Anti-Patterns by Impact

| Rank | Anti-Pattern | Criteria | Why Critical |
|------|--------------|----------|--------------|
| 1 | **Ghost Tool Usage** | 8 | Project fails core purpose (using data) |
| 2 | **Missing Examples** | 6 | Causes unreliable tool triggering |

---
*Generated by LLM-based semantic extraction*
</file_content>

<file_content path="requirements.txt">
# Core LangChain dependencies
langchain>=0.3.25
langchain-core==0.3.76
langchain-openai==0.3.6
langchain-community==0.3.24
langchain-chroma==0.2.6
langgraph==0.2.76

# Database dependencies
sqlalchemy==2.0.23

# Vector store and embeddings
chromadb==1.1.1
openai>=1.58.1

pydantic==2.12.1
# Data processing
pandas==2.1.4
numpy==1.26.4

# Environment and configuration
python-dotenv==1.0.0

# Jupyter notebook dependencies
jupyter==1.0.0
ipykernel==6.25.2

# Evaluation and testing
pytest==7.4.3
pytest-asyncio==0.21.1

# Additional utilities
requests==2.31.0
python-dateutil==2.8.2
</file_content>

<file_content path="temp_db_setup.py">
# Import the necessary libraries
from datetime import datetime, timedelta
import random

from models.energy import DatabaseManager

# Create a DatabaseManager instance
# Initialize it with the path "data/energy_data.db"
db_manager = DatabaseManager("data/energy_data.db")

# Create the database tables
# Use the create_tables() method from your DatabaseManager
db_manager.create_tables()

# Generate sample energy usage data for the past 30 days
# Include different device types: EV, HVAC, appliances
# Use realistic consumption patterns (higher during peak hours)

# Device types and their typical consumption patterns
device_types = {
    'EV': {'base_kwh': 10, 'variation': 5, 'peak_hours': [18, 19, 20, 21]},
    'HVAC': {'base_kwh': 2, 'variation': 1, 'peak_hours': [12, 13, 14, 15, 16, 17]},
    'appliance': {'base_kwh': 1.5, 'variation': 0.5, 'peak_hours': [19, 20, 21, 22]}
}

# Generate data for the past 30 days
start_date = datetime.now() - timedelta(days=30)
records_created = 0

for day in range(30):
    current_date = start_date + timedelta(days=day)
    
    for hour in range(24):
        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)
        
        # Generate usage for each device type
        for device_type, config in device_types.items():
            # Base consumption with variation
            base_consumption = config['base_kwh']
            variation = random.uniform(-config['variation'], config['variation'])
            
            # Peak hour multiplier
            peak_multiplier = 1.5 if hour in config['peak_hours'] else 0.8
            
            consumption = max(0, (base_consumption + variation) * peak_multiplier)
            
            # Calculate cost (simplified pricing)
            price_per_kwh = 0.15 if hour in config['peak_hours'] else 0.10
            cost = consumption * price_per_kwh
            
            # Device names
            device_names = {
                'EV': 'Tesla Model 3',
                'HVAC': 'Main AC Unit',
                'appliance': random.choice(['Dishwasher', 'Washing Machine', 'Dryer'])
            }
            
            # Add record to database
            db_manager.add_usage_record(
                timestamp=timestamp,
                consumption_kwh=consumption,
                device_type=device_type,
                device_name=device_names[device_type],
                cost_usd=cost
            )
            records_created += 1

print(f"Created {records_created} energy usage records")

# Generate sample solar generation data
# Consider weather patterns, time of day, and seasonal variations

# Weather conditions and their impact on solar generation
weather_conditions = {
    'sunny': {'multiplier': 1.0, 'probability': 0.4},
    'partly_cloudy': {'multiplier': 0.6, 'probability': 0.3},
    'cloudy': {'multiplier': 0.3, 'probability': 0.2},
    'rainy': {'multiplier': 0.1, 'probability': 0.1}
}

# Generate solar generation data for the same period
start_date = datetime.now() - timedelta(days=30)
generation_records = 0

for day in range(30):
    current_date = start_date + timedelta(days=day)
    
    # Select weather condition for the day
    weather_choice = random.choices(
        list(weather_conditions.keys()),
        weights=[weather_conditions[w]['probability'] for w in weather_conditions.keys()]
    )[0]
    weather_multiplier = weather_conditions[weather_choice]['multiplier']
    
    for hour in range(24):
        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)
        
        # Solar generation only during daylight hours (6 AM to 6 PM)
        if 6 <= hour <= 18:
            # Base generation curve (peak at noon)
            hour_factor = 1 - abs(hour - 12) / 6  # Peak at hour 12
            base_generation = 5.0 * hour_factor  # Max 5 kWh at peak
            
            # Apply weather multiplier
            generation = base_generation * weather_multiplier
            
            # Add some random variation
            generation *= random.uniform(0.8, 1.2)
            generation = max(0, generation)
            
            # Calculate temperature (affects solar efficiency)
            base_temp = 20 + random.uniform(-5, 5)
            temp_factor = 1.0 if 15 <= base_temp <= 35 else 0.9
            
            # Solar irradiance calculation
            irradiance = 800 * hour_factor * weather_multiplier if generation > 0 else 0
            
            # Add record to database
            db_manager.add_generation_record(
                timestamp=timestamp,
                generation_kwh=generation,
                weather_condition=weather_choice,
                temperature_c=base_temp * temp_factor,
                solar_irradiance=irradiance
            )
            generation_records += 1

print(f"Created {generation_records} solar generation records")

# Query the data to verify it was inserted correctly
# Show total consumption by device type
# Show daily solar generation patterns
# Calculate some basic statistics

# Get recent data for analysis
recent_usage = db_manager.get_recent_usage(24)  # Last 24 hours
recent_generation = db_manager.get_recent_generation(24)

print("=== Energy Usage Analysis ===")
print(f"Total records in last 24 hours: {len(recent_usage)}")

# Group by device type
device_consumption = {}
for record in recent_usage:
    device = record.device_type or 'unknown'
    if device not in device_consumption:
        device_consumption[device] = {'kwh': 0, 'cost': 0, 'records': 0}
    device_consumption[device]['kwh'] += record.consumption_kwh
    device_consumption[device]['cost'] += record.cost_usd or 0
    device_consumption[device]['records'] += 1

print("\nConsumption by device type:")
for device, data in device_consumption.items():
    print(f"  {device}: {data['kwh']:.2f} kWh, ${data['cost']:.2f}, {data['records']} records")

print(f"\n=== Solar Generation Analysis ===")
print(f"Total generation records in last 24 hours: {len(recent_generation)}")

total_generation = sum(r.generation_kwh for r in recent_generation)
print(f"Total generation: {total_generation:.2f} kWh")

# Weather breakdown
weather_breakdown = {}
for record in recent_generation:
    weather = record.weather_condition or 'unknown'
    if weather not in weather_breakdown:
        weather_breakdown[weather] = {'kwh': 0, 'records': 0}
    weather_breakdown[weather]['kwh'] += record.generation_kwh
    weather_breakdown[weather]['records'] += 1

print("\nGeneration by weather condition:")
for weather, data in weather_breakdown.items():
    print(f"  {weather}: {data['kwh']:.2f} kWh, {data['records']} records")

# Test the database query functions from tools.py
# Import and test: query_energy_usage, query_solar_generation, get_recent_energy_summary

from tools import query_energy_usage, query_solar_generation, get_recent_energy_summary

# Test querying data for the last 7 days
end_date = datetime.now().strftime("%Y-%m-%d")
start_date = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d")

print("=== Testing Database Tools ===")
print(f"Querying data from {start_date} to {end_date}")

# Test energy usage query
usage_data = query_energy_usage.invoke(
    input={
        "start_date": start_date, 
        "end_date": end_date,
    }
)
print(f"\nEnergy Usage Query Results:")
print(f"  Total records: {usage_data['total_records']}")
print(f"  Total consumption: {usage_data['total_consumption_kwh']} kWh")
print(f"  Total cost: ${usage_data['total_cost_usd']}")

# Test solar generation query
generation_data = query_solar_generation.invoke(
    input={
        "start_date": start_date, 
        "end_date": end_date,
    }
)
print(f"\nSolar Generation Query Results:")
print(f"  Total records: {generation_data['total_records']}")
print(f"  Total generation: {generation_data['total_generation_kwh']} kWh")
print(f"  Average daily: {generation_data['average_daily_generation']} kWh")

# Test recent energy summary
summary = get_recent_energy_summary.invoke(
    input={
        "hours": 24
    }
)
print(f"\nRecent Energy Summary:")
print(f"  Usage: {summary['usage']['total_consumption_kwh']} kWh, ${summary['usage']['total_cost_usd']}")
print(f"  Generation: {summary['generation']['total_generation_kwh']} kWh")
print(f"  Weather: {summary['generation']['average_weather']}")
</file_content>

<file_content path="tools.py">
"""
Tools for EcoHome Energy Advisor Agent
"""
import os
import json
import random
from datetime import datetime, timedelta
from typing import Dict, Any
from langchain_core.tools import tool
from langchain_chroma import Chroma
from langchain_openai import OpenAIEmbeddings
from langchain_community.document_loaders import TextLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from models.energy import DatabaseManager

# Initialize database manager
db_manager = DatabaseManager()

@tool
def get_weather_forecast(location: str, days: int = 3) -> Dict[str, Any]:
    """
    Get weather forecast for a specific location and number of days.

    Args:
        location (str): Location to get weather for (e.g., "San Francisco, CA")
        days (int): Number of days to forecast (1-7)

    Returns:
        Dict[str, Any]: Weather forecast data including temperature, conditions, and solar irradiance
        E.g:
        forecast = {
            "location": ...,
            "forecast_days": ...,
            "current": {
                "temperature_c": ...,
                "condition": random.choice(["sunny", "partly_cloudy", "cloudy"]),
                "humidity": ...,
                "wind_speed": ...
            },
            "hourly": [
                {
                    "hour": ..., # for hour in range(24)
                    "temperature_c": ...,
                    "condition": ...,
                    "solar_irradiance": ...,
                    "humidity": ...,
                    "wind_speed": ...
                },
            ]
        }
    """
    # Mock weather API - in production, use OpenWeatherMap or similar
    try:
        days = min(max(days, 1), 7)  # Limit to 1-7 days

        # Generate current weather
        current_condition = random.choice(["sunny", "partly_cloudy", "cloudy", "rainy"])
        current_temp = random.uniform(15, 30)

        forecast = {
            "location": location,
            "forecast_days": days,
            "generated_at": datetime.now().isoformat(),
            "current": {
                "temperature_c": round(current_temp, 1),
                "condition": current_condition,
                "humidity": random.randint(40, 80),
                "wind_speed": round(random.uniform(5, 20), 1)
            },
            "daily": []
        }

        # Generate forecast for each day
        for day in range(days):
            date = datetime.now() + timedelta(days=day)

            # Weather patterns with some continuity
            if day == 0:
                condition = current_condition
            else:
                # 60% chance to keep same weather, 40% to change
                if random.random() < 0.6:
                    condition = forecast["daily"][day-1]["condition"]
                else:
                    condition = random.choice(["sunny", "partly_cloudy", "cloudy", "rainy"])

            # Generate hourly forecast
            hourly_data = []
            for hour in range(24):
                # Temperature variation throughout day
                base_temp = 15 + 10 * (1 - abs(hour - 13) / 13)  # Peak at 1 PM
                temp_variation = random.uniform(-2, 2)
                temp = base_temp + temp_variation

                # Solar irradiance based on time of day and weather
                if 6 <= hour <= 18:
                    hour_factor = 1 - abs(hour - 12) / 6
                    weather_multipliers = {
                        "sunny": 1.0,
                        "partly_cloudy": 0.6,
                        "cloudy": 0.3,
                        "rainy": 0.1
                    }
                    solar_irradiance = 800 * hour_factor * weather_multipliers[condition]
                else:
                    solar_irradiance = 0

                hourly_data.append({
                    "hour": hour,
                    "temperature_c": round(temp, 1),
                    "condition": condition,
                    "solar_irradiance": round(solar_irradiance, 1),
                    "humidity": random.randint(40, 80),
                    "wind_speed": round(random.uniform(5, 20), 1)
                })

            forecast["daily"].append({
                "date": date.strftime("%Y-%m-%d"),
                "condition": condition,
                "temp_high_c": round(max(h["temperature_c"] for h in hourly_data), 1),
                "temp_low_c": round(min(h["temperature_c"] for h in hourly_data), 1),
                "hourly": hourly_data
            })

        return forecast
    except Exception as e:
        return {"error": f"Failed to get weather forecast: {str(e)}"} 

@tool
def get_electricity_prices(date: str = None) -> Dict[str, Any]:
    """
    Get electricity prices for a specific date or current day.

    Args:
        date (str): Date in YYYY-MM-DD format (defaults to today)

    Returns:
        Dict[str, Any]: Electricity pricing data with hourly rates
        E.g:
        prices = {
            "date": ...,
            "pricing_type": "time_of_use",
            "currency": "USD",
            "unit": "per_kWh",
            "hourly_rates": [
                {
                    "hour": .., # for hour in range(24)
                    "rate": ..,
                    "period": ..,
                    "demand_charge": ...
                }
            ]
        }
    """
    try:
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")

        # Mock electricity pricing - in real implementation, this would call a pricing API
        # Base prices per kWh
        base_price = 0.10
        mid_peak_price = 0.15
        peak_price = 0.25

        # Demand charges (additional cost during peak times)
        peak_demand_charge = 0.05

        hourly_rates = []
        for hour in range(24):
            # Determine period and rate based on time of day
            # Off-peak: midnight-6am, 10pm-midnight
            # Mid-peak: 6am-4pm (excluding 12pm-6pm), 8pm-10pm
            # Peak: 4pm-8pm (typically highest demand)

            if 0 <= hour < 6 or hour >= 22:
                period = "off_peak"
                rate = base_price
                demand_charge = 0
            elif (6 <= hour < 16) or (20 <= hour < 22):
                period = "mid_peak"
                rate = mid_peak_price
                demand_charge = 0
            else:  # 16-20 (4pm-8pm)
                period = "peak"
                rate = peak_price
                demand_charge = peak_demand_charge

            hourly_rates.append({
                "hour": hour,
                "rate": round(rate, 3),
                "period": period,
                "demand_charge": round(demand_charge, 3),
                "total_rate": round(rate + demand_charge, 3)
            })

        prices = {
            "date": date,
            "pricing_type": "time_of_use",
            "currency": "USD",
            "unit": "per_kWh",
            "hourly_rates": hourly_rates,
            "summary": {
                "off_peak_rate": base_price,
                "mid_peak_rate": mid_peak_price,
                "peak_rate": peak_price + peak_demand_charge,
                "peak_hours": "16:00-20:00",
                "off_peak_hours": "00:00-06:00, 22:00-24:00"
            }
        }

        return prices
    except Exception as e:
        return {"error": f"Failed to get electricity prices: {str(e)}"} 

@tool
def query_energy_usage(start_date: str, end_date: str, device_type: str = None) -> Dict[str, Any]:
    """
    Query energy usage data from the database for a specific date range.
    
    Args:
        start_date (str): Start date in YYYY-MM-DD format
        end_date (str): End date in YYYY-MM-DD format
        device_type (str): Optional device type filter (e.g., "EV", "HVAC", "appliance")
    
    Returns:
        Dict[str, Any]: Energy usage data with consumption details
    """
    try:
        start_dt = datetime.strptime(start_date, "%Y-%m-%d")
        end_dt = datetime.strptime(end_date, "%Y-%m-%d") + timedelta(days=1)
        
        records = db_manager.get_usage_by_date_range(start_dt, end_dt)
        
        if device_type:
            records = [r for r in records if r.device_type == device_type]
        
        usage_data = {
            "start_date": start_date,
            "end_date": end_date,
            "device_type": device_type,
            "total_records": len(records),
            "total_consumption_kwh": round(sum(r.consumption_kwh for r in records), 2),
            "total_cost_usd": round(sum(r.cost_usd or 0 for r in records), 2),
            "records": []
        }
        
        for record in records:
            usage_data["records"].append({
                "timestamp": record.timestamp.isoformat(),
                "consumption_kwh": record.consumption_kwh,
                "device_type": record.device_type,
                "device_name": record.device_name,
                "cost_usd": record.cost_usd
            })
        
        return usage_data
    except Exception as e:
        return {"error": f"Failed to query energy usage: {str(e)}"}

@tool
def query_solar_generation(start_date: str, end_date: str) -> Dict[str, Any]:
    """
    Query solar generation data from the database for a specific date range.
    
    Args:
        start_date (str): Start date in YYYY-MM-DD format
        end_date (str): End date in YYYY-MM-DD format
    
    Returns:
        Dict[str, Any]: Solar generation data with production details
    """
    try:
        start_dt = datetime.strptime(start_date, "%Y-%m-%d")
        end_dt = datetime.strptime(end_date, "%Y-%m-%d") + timedelta(days=1)
        
        records = db_manager.get_generation_by_date_range(start_dt, end_dt)
        
        generation_data = {
            "start_date": start_date,
            "end_date": end_date,
            "total_records": len(records),
            "total_generation_kwh": round(sum(r.generation_kwh for r in records), 2),
            "average_daily_generation": round(sum(r.generation_kwh for r in records) / max(1, (end_dt - start_dt).days), 2),
            "records": []
        }
        
        for record in records:
            generation_data["records"].append({
                "timestamp": record.timestamp.isoformat(),
                "generation_kwh": record.generation_kwh,
                "weather_condition": record.weather_condition,
                "temperature_c": record.temperature_c,
                "solar_irradiance": record.solar_irradiance
            })
        
        return generation_data
    except Exception as e:
        return {"error": f"Failed to query solar generation: {str(e)}"}

@tool
def get_recent_energy_summary(hours: int = 24) -> Dict[str, Any]:
    """
    Get a summary of recent energy usage and solar generation.
    
    Args:
        hours (int): Number of hours to look back (default 24)
    
    Returns:
        Dict[str, Any]: Summary of recent energy data
    """
    try:
        usage_records = db_manager.get_recent_usage(hours)
        generation_records = db_manager.get_recent_generation(hours)
        
        summary = {
            "time_period_hours": hours,
            "usage": {
                "total_consumption_kwh": round(sum(r.consumption_kwh for r in usage_records), 2),
                "total_cost_usd": round(sum(r.cost_usd or 0 for r in usage_records), 2),
                "device_breakdown": {}
            },
            "generation": {
                "total_generation_kwh": round(sum(r.generation_kwh for r in generation_records), 2),
                "average_weather": "sunny" if generation_records else "unknown"
            }
        }
        
        # Calculate device breakdown
        for record in usage_records:
            device = record.device_type or "unknown"
            if device not in summary["usage"]["device_breakdown"]:
                summary["usage"]["device_breakdown"][device] = {
                    "consumption_kwh": 0,
                    "cost_usd": 0,
                    "records": 0
                }
            summary["usage"]["device_breakdown"][device]["consumption_kwh"] += record.consumption_kwh
            summary["usage"]["device_breakdown"][device]["cost_usd"] += record.cost_usd or 0
            summary["usage"]["device_breakdown"][device]["records"] += 1
        
        # Round the breakdown values
        for device_data in summary["usage"]["device_breakdown"].values():
            device_data["consumption_kwh"] = round(device_data["consumption_kwh"], 2)
            device_data["cost_usd"] = round(device_data["cost_usd"], 2)
        
        return summary
    except Exception as e:
        return {"error": f"Failed to get recent energy summary: {str(e)}"}

@tool
def search_energy_tips(query: str, max_results: int = 5) -> Dict[str, Any]:
    """
    Search for energy-saving tips and best practices using RAG.
    
    Args:
        query (str): Search query for energy tips
        max_results (int): Maximum number of results to return
    
    Returns:
        Dict[str, Any]: Relevant energy tips and best practices
    """
    try:
        # Initialize vector store if it doesn't exist
        persist_directory = "data/vectorstore"
        if not os.path.exists(persist_directory):
            os.makedirs(persist_directory)
        
        # Load documents if vector store doesn't exist
        if not os.path.exists(os.path.join(persist_directory, "chroma.sqlite3")):
            # Load documents
            documents = []
            for doc_path in ["data/documents/tip_device_best_practices.txt", "data/documents/tip_energy_savings.txt"]:
                if os.path.exists(doc_path):
                    loader = TextLoader(doc_path)
                    docs = loader.load()
                    documents.extend(docs)
            
            # Split documents
            text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
            splits = text_splitter.split_documents(documents)
            
            # Create vector store
            embeddings = OpenAIEmbeddings()
            vectorstore = Chroma.from_documents(
                documents=splits,
                embedding=embeddings,
                persist_directory=persist_directory
            )
        else:
            # Load existing vector store
            embeddings = OpenAIEmbeddings()
            vectorstore = Chroma(
                persist_directory=persist_directory,
                embedding_function=embeddings
            )
        
        # Search for relevant documents
        docs = vectorstore.similarity_search(query, k=max_results)
        
        results = {
            "query": query,
            "total_results": len(docs),
            "tips": []
        }
        
        for i, doc in enumerate(docs):
            results["tips"].append({
                "rank": i + 1,
                "content": doc.page_content,
                "source": doc.metadata.get("source", "unknown"),
                "relevance_score": "high" if i < 2 else "medium" if i < 4 else "low"
            })
        
        return results
    except Exception as e:
        return {"error": f"Failed to search energy tips: {str(e)}"}

@tool
def calculate_energy_savings(device_type: str, current_usage_kwh: float, 
                           optimized_usage_kwh: float, price_per_kwh: float = 0.12) -> Dict[str, Any]:
    """
    Calculate potential energy savings from optimization.
    
    Args:
        device_type (str): Type of device being optimized
        current_usage_kwh (float): Current energy usage in kWh
        optimized_usage_kwh (float): Optimized energy usage in kWh
        price_per_kwh (float): Price per kWh (default 0.12)
    
    Returns:
        Dict[str, Any]: Savings calculation results
    """
    savings_kwh = current_usage_kwh - optimized_usage_kwh
    savings_usd = savings_kwh * price_per_kwh
    savings_percentage = (savings_kwh / current_usage_kwh) * 100 if current_usage_kwh > 0 else 0
    
    return {
        "device_type": device_type,
        "current_usage_kwh": current_usage_kwh,
        "optimized_usage_kwh": optimized_usage_kwh,
        "savings_kwh": round(savings_kwh, 2),
        "savings_usd": round(savings_usd, 2),
        "savings_percentage": round(savings_percentage, 1),
        "price_per_kwh": price_per_kwh,
        "annual_savings_usd": round(savings_usd * 365, 2)
    }


TOOL_KIT = [
    get_weather_forecast,
    get_electricity_prices,
    query_energy_usage,
    query_solar_generation,
    get_recent_energy_summary,
    search_energy_tips,
    calculate_energy_savings
]
</file_content>

<file_content path="visual_antipatterns_guide.md">
# ð« Agent Anti-Patterns Visual Guide

> **Purpose**: A visual reference for LLMs to generate educational slides and infographics about common agent development mistakes.

## ð Executive Summary

**Total Failures Analyzed**: 0

| Category | Count | Impact Level |
|----------|-------|-------------|

## ðºï¸ Anti-Pattern Landscape

```mermaid
mindmap
  root((Agent\nAnti-Patterns))
```

## ð¨ Slide Generation Hints

When generating slides from this document:

1. **Title Slide**: Use the executive summary statistics
2. **Category Slides**: One slide per category with the mindmap subsection
3. **Deep Dive Slides**: Before/After code comparisons with visual metaphors
4. **Impact Slides**: Use frequency bars to show which issues are most common
5. **Takeaway Slide**: Summarize the top 3 anti-patterns to avoid

### Color Coding Reference

| Color | Meaning |
|-------|--------|
| ð´ Red | Critical issue (>100 occurrences) |
| ð¡ Yellow | Moderate issue (20-100 occurrences) |
| ð¢ Green | Low frequency (<20 occurrences) |
</file_content>

<file_content path="models/__init__.py">
# EcoHome Models
</file_content>

<file_content path="models/energy.py">
"""
Energy data models for EcoHome Energy Advisor
"""
from datetime import datetime
from typing import Optional
from sqlalchemy import Column, Integer, Float, DateTime, String, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

Base = declarative_base()

class EnergyUsage(Base):
    """Model for energy consumption data"""
    __tablename__ = "energy_usage"
    
    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    consumption_kwh = Column(Float, nullable=False)
    device_type = Column(String(50), nullable=True)  # e.g., "EV", "HVAC", "appliance"
    device_name = Column(String(100), nullable=True)  # e.g., "Tesla Model 3", "Main AC"
    cost_usd = Column(Float, nullable=True)  # Cost at time of usage
    
    def __repr__(self):
        return f"<EnergyUsage(timestamp={self.timestamp}, consumption={self.consumption_kwh}kWh, device={self.device_name})>"

class SolarGeneration(Base):
    """Model for solar generation data"""
    __tablename__ = "solar_generation"
    
    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    generation_kwh = Column(Float, nullable=False)
    weather_condition = Column(String(50), nullable=True)  # e.g., "sunny", "cloudy", "rainy"
    temperature_c = Column(Float, nullable=True)
    solar_irradiance = Column(Float, nullable=True)  # W/mÂ²
    
    def __repr__(self):
        return f"<SolarGeneration(timestamp={self.timestamp}, generation={self.generation_kwh}kWh, weather={self.weather_condition})>"

class DatabaseManager:
    """Database manager for EcoHome energy data"""
    
    def __init__(self, db_path: str = "data/energy_data.db"):
        self.db_path = db_path
        self.engine = create_engine(f"sqlite:///{db_path}")
        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
        
    def create_tables(self):
        """Create all tables"""
        Base.metadata.create_all(bind=self.engine)
        print(f"Database tables created at {self.db_path}")
    
    def get_session(self):
        """Get database session"""
        return self.SessionLocal()
    
    def add_usage_record(self, timestamp: datetime, consumption_kwh: float, 
                        device_type: str = None, device_name: str = None, cost_usd: float = None):
        """Add energy usage record"""
        session = self.get_session()
        try:
            record = EnergyUsage(
                timestamp=timestamp,
                consumption_kwh=consumption_kwh,
                device_type=device_type,
                device_name=device_name,
                cost_usd=cost_usd
            )
            session.add(record)
            session.commit()
            return record
        finally:
            session.close()
    
    def add_generation_record(self, timestamp: datetime, generation_kwh: float,
                            weather_condition: str = None, temperature_c: float = None,
                            solar_irradiance: float = None):
        """Add solar generation record"""
        session = self.get_session()
        try:
            record = SolarGeneration(
                timestamp=timestamp,
                generation_kwh=generation_kwh,
                weather_condition=weather_condition,
                temperature_c=temperature_c,
                solar_irradiance=solar_irradiance
            )
            session.add(record)
            session.commit()
            return record
        finally:
            session.close()
    
    def get_usage_by_date_range(self, start_date: datetime, end_date: datetime):
        """Get energy usage records within date range"""
        session = self.get_session()
        try:
            return session.query(EnergyUsage).filter(
                EnergyUsage.timestamp >= start_date,
                EnergyUsage.timestamp <= end_date
            ).order_by(EnergyUsage.timestamp).all()
        finally:
            session.close()
    
    def get_generation_by_date_range(self, start_date: datetime, end_date: datetime):
        """Get solar generation records within date range"""
        session = self.get_session()
        try:
            return session.query(SolarGeneration).filter(
                SolarGeneration.timestamp >= start_date,
                SolarGeneration.timestamp <= end_date
            ).order_by(SolarGeneration.timestamp).all()
        finally:
            session.close()
    
    def get_recent_usage(self, hours: int = 24):
        """Get recent usage records"""
        from datetime import datetime, timedelta
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)
        return self.get_usage_by_date_range(start_time, end_time)
    
    def get_recent_generation(self, hours: int = 24):
        """Get recent solar generation records"""
        from datetime import datetime, timedelta
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)
        return self.get_generation_by_date_range(start_time, end_time)
</file_content>

<file_content path="master_project/01_db_setup.ipynb">
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EcoHome Energy Advisor - Database Setup\n",
    "\n",
    "In this notebook, you'll set up the database for the EcoHome Energy Advisor. The database will store:\n",
    "- Energy usage data (consumption, device types, costs)\n",
    "- Solar generation data (production, weather conditions)\n",
    "\n",
    "## Learning Objectives\n",
    "- Create SQLite database with proper schema\n",
    "- Populate database with sample data\n",
    "- Query data for analysis\n",
    "- Understand database design for energy management\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Import Required Libraries\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[33mWARNING: The candidate selected for download or install is a yanked version: 'pydantic' candidate (version 2.12.1 at https://files.pythonhosted.org/packages/f5/69/ce4e60e5e67aa0c339a5dc3391a02b4036545efb6308c54dc4aa9425386f/pydantic-2.12.1-py3-none-any.whl (from https://pypi.org/simple/pydantic/) (requires-python:>=3.9))\n",
      "Reason for being yanked: references a yanked version of pydantic-core\u001b[0m\u001b[33m\n",
      "\u001b[0m\u001b[33mWARNING: The candidate selected for download or install is a yanked version: 'pydantic-core' candidate (version 2.41.3 at https://files.pythonhosted.org/packages/43/05/362832ea8b890f5821ada95cd72a0da1b2466f88f6ac1a47cf1350136722/pydantic_core-2.41.3-cp311-cp311-macosx_11_0_arm64.whl (from https://pypi.org/simple/pydantic-core/) (requires-python:>=3.9))\n",
      "Reason for being yanked: corrupted wheel got uploaded\u001b[0m\u001b[33m\n",
      "\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m24.3.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.2\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpython3.11 -m pip install --upgrade pip\u001b[0m\n",
      "Note: you may need to restart the kernel to use updated packages.\n"
     ]
    }
   ],
   "source": [
    "%pip install -q sqlalchemy==2.0.23 langchain==0.3.25 langchain-core==0.3.76 langchain-openai==0.3.6 langchain-community==0.3.24 langchain-chroma==0.2.6 langgraph==0.2.76 numpy==1.26.4 pydantic==2.12.1 chromadb==1.1.1 openai==1.58.1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import the necessary libraries\n",
    "from datetime import datetime, timedelta\n",
    "import random\n",
    "\n",
    "from models.energy import DatabaseManager"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Initialize Database Manager\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a DatabaseManager instance\n",
    "# Initialize it with the path \"data/energy_data.db\"\n",
    "db_manager = DatabaseManager(\"data/energy_data.db\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Create Database Tables\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Database tables created at data/energy_data.db\n"
     ]
    }
   ],
   "source": [
    "# Create the database tables\n",
    "# Use the create_tables() method from your DatabaseManager\n",
    "db_manager.create_tables()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Generate Sample Energy Usage Data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Created 2160 energy usage records\n"
     ]
    }
   ],
   "source": [
    "# Generate sample energy usage data for the past 30 days\n",
    "# Include different device types: EV, HVAC, appliances\n",
    "# Use realistic consumption patterns (higher during peak hours)\n",
    "\n",
    "# Device types and their typical consumption patterns\n",
    "device_types = {\n",
    "    'EV': {'base_kwh': 10, 'variation': 5, 'peak_hours': [18, 19, 20, 21]},\n",
    "    'HVAC': {'base_kwh': 2, 'variation': 1, 'peak_hours': [12, 13, 14, 15, 16, 17]},\n",
    "    'appliance': {'base_kwh': 1.5, 'variation': 0.5, 'peak_hours': [19, 20, 21, 22]}\n",
    "}\n",
    "\n",
    "# Generate data for the past 30 days\n",
    "start_date = datetime.now() - timedelta(days=30)\n",
    "records_created = 0\n",
    "\n",
    "for day in range(30):\n",
    "    current_date = start_date + timedelta(days=day)\n",
    "    \n",
    "    for hour in range(24):\n",
    "        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)\n",
    "        \n",
    "        # Generate usage for each device type\n",
    "        for device_type, config in device_types.items():\n",
    "            # Base consumption with variation\n",
    "            base_consumption = config['base_kwh']\n",
    "            variation = random.uniform(-config['variation'], config['variation'])\n",
    "            \n",
    "            # Peak hour multiplier\n",
    "            peak_multiplier = 1.5 if hour in config['peak_hours'] else 0.8\n",
    "            \n",
    "            consumption = max(0, (base_consumption + variation) * peak_multiplier)\n",
    "            \n",
    "            # Calculate cost (simplified pricing)\n",
    "            price_per_kwh = 0.15 if hour in config['peak_hours'] else 0.10\n",
    "            cost = consumption * price_per_kwh\n",
    "            \n",
    "            # Device names\n",
    "            device_names = {\n",
    "                'EV': 'Tesla Model 3',\n",
    "                'HVAC': 'Main AC Unit',\n",
    "                'appliance': random.choice(['Dishwasher', 'Washing Machine', 'Dryer'])\n",
    "            }\n",
    "            \n",
    "            # Add record to database\n",
    "            db_manager.add_usage_record(\n",
    "                timestamp=timestamp,\n",
    "                consumption_kwh=consumption,\n",
    "                device_type=device_type,\n",
    "                device_name=device_names[device_type],\n",
    "                cost_usd=cost\n",
    "            )\n",
    "            records_created += 1\n",
    "\n",
    "print(f\"Created {records_created} energy usage records\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Generate Sample Solar Generation Data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Created 390 solar generation records\n"
     ]
    }
   ],
   "source": [
    "# Generate sample solar generation data\n",
    "# Consider weather patterns, time of day, and seasonal variations\n",
    "\n",
    "# Weather conditions and their impact on solar generation\n",
    "weather_conditions = {\n",
    "    'sunny': {'multiplier': 1.0, 'probability': 0.4},\n",
    "    'partly_cloudy': {'multiplier': 0.6, 'probability': 0.3},\n",
    "    'cloudy': {'multiplier': 0.3, 'probability': 0.2},\n",
    "    'rainy': {'multiplier': 0.1, 'probability': 0.1}\n",
    "}\n",
    "\n",
    "# Generate solar generation data for the same period\n",
    "start_date = datetime.now() - timedelta(days=30)\n",
    "generation_records = 0\n",
    "\n",
    "for day in range(30):\n",
    "    current_date = start_date + timedelta(days=day)\n",
    "    \n",
    "    # Select weather condition for the day\n",
    "    weather_choice = random.choices(\n",
    "        list(weather_conditions.keys()),\n",
    "        weights=[weather_conditions[w]['probability'] for w in weather_conditions.keys()]\n",
    "    )[0]\n",
    "    weather_multiplier = weather_conditions[weather_choice]['multiplier']\n",
    "    \n",
    "    for hour in range(24):\n",
    "        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)\n",
    "        \n",
    "        # Solar generation only during daylight hours (6 AM to 6 PM)\n",
    "        if 6 <= hour <= 18:\n",
    "            # Base generation curve (peak at noon)\n",
    "            hour_factor = 1 - abs(hour - 12) / 6  # Peak at hour 12\n",
    "            base_generation = 5.0 * hour_factor  # Max 5 kWh at peak\n",
    "            \n",
    "            # Apply weather multiplier\n",
    "            generation = base_generation * weather_multiplier\n",
    "            \n",
    "            # Add some random variation\n",
    "            generation *= random.uniform(0.8, 1.2)\n",
    "            generation = max(0, generation)\n",
    "            \n",
    "            # Calculate temperature (affects solar efficiency)\n",
    "            base_temp = 20 + random.uniform(-5, 5)\n",
    "            temp_factor = 1.0 if 15 <= base_temp <= 35 else 0.9\n",
    "            \n",
    "            # Solar irradiance calculation\n",
    "            irradiance = 800 * hour_factor * weather_multiplier if generation > 0 else 0\n",
    "            \n",
    "            # Add record to database\n",
    "            db_manager.add_generation_record(\n",
    "                timestamp=timestamp,\n",
    "                generation_kwh=generation,\n",
    "                weather_condition=weather_choice,\n",
    "                temperature_c=base_temp * temp_factor,\n",
    "                solar_irradiance=irradiance\n",
    "            )\n",
    "            generation_records += 1\n",
    "\n",
    "print(f\"Created {generation_records} solar generation records\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Query and Analyze Data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Energy Usage Analysis ===\n",
      "Total records in last 24 hours: 105\n",
      "\n",
      "Consumption by device type:\n",
      "  EV: 409.75 kWh, $55.33, 35 records\n",
      "  HVAC: 62.32 kWh, $7.00, 35 records\n",
      "  appliance: 63.55 kWh, $8.69, 35 records\n",
      "\n",
      "=== Solar Generation Analysis ===\n",
      "Total generation records in last 24 hours: 10\n",
      "Total generation: 2.69 kWh\n",
      "\n",
      "Generation by weather condition:\n",
      "  sunny: 1.64 kWh, 4 records\n",
      "  partly_cloudy: 0.84 kWh, 4 records\n",
      "  cloudy: 0.21 kWh, 2 records\n"
     ]
    }
   ],
   "source": [
    "# Query the data to verify it was inserted correctly\n",
    "# Show total consumption by device type\n",
    "# Show daily solar generation patterns\n",
    "# Calculate some basic statistics\n",
    "\n",
    "# Get recent data for analysis\n",
    "recent_usage = db_manager.get_recent_usage(24)  # Last 24 hours\n",
    "recent_generation = db_manager.get_recent_generation(24)\n",
    "\n",
    "print(\"=== Energy Usage Analysis ===\")\n",
    "print(f\"Total records in last 24 hours: {len(recent_usage)}\")\n",
    "\n",
    "# Group by device type\n",
    "device_consumption = {}\n",
    "for record in recent_usage:\n",
    "    device = record.device_type or 'unknown'\n",
    "    if device not in device_consumption:\n",
    "        device_consumption[device] = {'kwh': 0, 'cost': 0, 'records': 0}\n",
    "    device_consumption[device]['kwh'] += record.consumption_kwh\n",
    "    device_consumption[device]['cost'] += record.cost_usd or 0\n",
    "    device_consumption[device]['records'] += 1\n",
    "\n",
    "print(\"\\nConsumption by device type:\")\n",
    "for device, data in device_consumption.items():\n",
    "    print(f\"  {device}: {data['kwh']:.2f} kWh, ${data['cost']:.2f}, {data['records']} records\")\n",
    "\n",
    "print(f\"\\n=== Solar Generation Analysis ===\")\n",
    "print(f\"Total generation records in last 24 hours: {len(recent_generation)}\")\n",
    "\n",
    "total_generation = sum(r.generation_kwh for r in recent_generation)\n",
    "print(f\"Total generation: {total_generation:.2f} kWh\")\n",
    "\n",
    "# Weather breakdown\n",
    "weather_breakdown = {}\n",
    "for record in recent_generation:\n",
    "    weather = record.weather_condition or 'unknown'\n",
    "    if weather not in weather_breakdown:\n",
    "        weather_breakdown[weather] = {'kwh': 0, 'records': 0}\n",
    "    weather_breakdown[weather]['kwh'] += record.generation_kwh\n",
    "    weather_breakdown[weather]['records'] += 1\n",
    "\n",
    "print(\"\\nGeneration by weather condition:\")\n",
    "for weather, data in weather_breakdown.items():\n",
    "    print(f\"  {weather}: {data['kwh']:.2f} kWh, {data['records']} records\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Test Database Tools\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/homebrew/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
      "  from .autonotebook import tqdm as notebook_tqdm\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Testing Database Tools ===\n",
      "Querying data from 2025-10-09 to 2025-10-16\n",
      "\n",
      "Energy Usage Query Results:\n",
      "  Total records: 5040\n",
      "  Total consumption: 21048.02 kWh\n",
      "  Total cost: $2413.83\n",
      "\n",
      "Solar Generation Query Results:\n",
      "  Total records: 910\n",
      "  Total generation: 1358.64 kWh\n",
      "  Average daily: 169.83 kWh\n",
      "\n",
      "Recent Energy Summary:\n",
      "  Usage: 535.62 kWh, $71.01\n",
      "  Generation: 2.69 kWh\n",
      "  Weather: sunny\n"
     ]
    }
   ],
   "source": [
    "# Test the database query functions from tools.py\n",
    "# Import and test: query_energy_usage, query_solar_generation, get_recent_energy_summary\n",
    "\n",
    "from tools import query_energy_usage, query_solar_generation, get_recent_energy_summary\n",
    "\n",
    "# Test querying data for the last 7 days\n",
    "end_date = datetime.now().strftime(\"%Y-%m-%d\")\n",
    "start_date = (datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\")\n",
    "\n",
    "print(\"=== Testing Database Tools ===\")\n",
    "print(f\"Querying data from {start_date} to {end_date}\")\n",
    "\n",
    "# Test energy usage query\n",
    "usage_data = query_energy_usage.invoke(\n",
    "    input={\n",
    "        \"start_date\": start_date, \n",
    "        \"end_date\": end_date,\n",
    "    }\n",
    ")\n",
    "print(f\"\\nEnergy Usage Query Results:\")\n",
    "print(f\"  Total records: {usage_data['total_records']}\")\n",
    "print(f\"  Total consumption: {usage_data['total_consumption_kwh']} kWh\")\n",
    "print(f\"  Total cost: ${usage_data['total_cost_usd']}\")\n",
    "\n",
    "# Test solar generation query\n",
    "generation_data = query_solar_generation.invoke(\n",
    "    input={\n",
    "        \"start_date\": start_date, \n",
    "        \"end_date\": end_date,\n",
    "    }\n",
    ")\n",
    "print(f\"\\nSolar Generation Query Results:\")\n",
    "print(f\"  Total records: {generation_data['total_records']}\")\n",
    "print(f\"  Total generation: {generation_data['total_generation_kwh']} kWh\")\n",
    "print(f\"  Average daily: {generation_data['average_daily_generation']} kWh\")\n",
    "\n",
    "# Test recent energy summary\n",
    "summary = get_recent_energy_summary.invoke(\n",
    "    input={\n",
    "        \"hours\": 24\n",
    "    }\n",
    ")\n",
    "print(f\"\\nRecent Energy Summary:\")\n",
    "print(f\"  Usage: {summary['usage']['total_consumption_kwh']} kWh, ${summary['usage']['total_cost_usd']}\")\n",
    "print(f\"  Generation: {summary['generation']['total_generation_kwh']} kWh\")\n",
    "print(f\"  Weather: {summary['generation']['average_weather']}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
</file_content>

<file_content path="master_project/02_rag_setup.ipynb">
{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# EcoHome Energy Advisor - RAG Setup\n",
        "\n",
        "In this notebook, you'll set up the Retrieval-Augmented Generation (RAG) pipeline for the EcoHome Energy Advisor. This will allow the agent to access and cite relevant energy-saving tips and best practices.\n",
        "\n",
        "## Learning Objectives\n",
        "- Set up ChromaDB vector store\n",
        "- Load and process energy-saving documents\n",
        "- Create embeddings for document chunks\n",
        "- Implement semantic search functionality\n",
        "- Test the RAG pipeline\n",
        "\n",
        "## Documents Available\n",
        "- `tip_device_best_practices.txt` - Device-specific optimization tips\n",
        "- `tip_energy_savings.txt` - General energy-saving strategies\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 1. Import Required Libraries\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {},
      "outputs": [
        {
          "name": "stderr",
          "output_type": "stream",
          "text": [
            "/opt/homebrew/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
            "  from .autonotebook import tqdm as notebook_tqdm\n"
          ]
        }
      ],
      "source": [
        "# Import the necessary libraries for RAG setup\n",
        "import os\n",
        "from langchain_chroma  import Chroma\n",
        "from langchain_openai import OpenAIEmbeddings\n",
        "from langchain_community.document_loaders import TextLoader\n",
        "from langchain.text_splitter import RecursiveCharacterTextSplitter\n",
        "from dotenv import load_dotenv"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [
        {
          "data": {
            "text/plain": [
              "True"
            ]
          },
          "execution_count": 2,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "load_dotenv()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2. Load and Process Documents\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Loaded 1 documents from data/documents/tip_renewable_energy_integration.txt\n",
            "Loaded 1 documents from data/documents/tip_device_best_practices.txt\n",
            "Loaded 1 documents from data/documents/tip_hvac_optimization.txt\n",
            "Loaded 1 documents from data/documents/tip_energy_storage_optimization.txt\n",
            "Loaded 1 documents from data/documents/tip_energy_savings.txt\n",
            "Loaded 1 documents from data/documents/tip_smart_home_automation.txt\n",
            "Loaded 1 documents from data/documents/tip_seasonal_energy_management.txt\n",
            "Total documents loaded: 7\n"
          ]
        }
      ],
      "source": [
        "# Load the energy-saving tip documents\n",
        "# Load all .txt files from the data/documents directory\n",
        "# Use TextLoader to load the documents\n",
        "\n",
        "documents = []\n",
        "doc_dir = \"data/documents\"\n",
        "document_paths = [os.path.join(doc_dir, f) for f in os.listdir(doc_dir) if f.endswith(\".txt\")]\n",
        "\n",
        "for doc_path in document_paths:\n",
        "    if os.path.exists(doc_path):\n",
        "        loader = TextLoader(doc_path)\n",
        "        docs = loader.load()\n",
        "        documents.extend(docs)\n",
        "        print(f\"Loaded {len(docs)} documents from {doc_path}\")\n",
        "    else:\n",
        "        print(f\"Warning: {doc_path} not found\")\n",
        "\n",
        "print(f\"Total documents loaded: {len(documents)}\")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 3. Split Documents into Chunks\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Split 7 documents into 25 chunks\n",
            "\n",
            "Sample chunk (first 200 characters):\n",
            "Renewable Energy Integration\n",
            "\n",
            "1.  Solar Photovoltaic (PV) Systems:\n",
            "    *   **Grid-Tied Systems:** Connected to the utility grid, allowing you to draw power when solar production is low and send excess...\n"
          ]
        }
      ],
      "source": [
        "# Split documents into smaller chunks for better retrieval\n",
        "# Use RecursiveCharacterTextSplitter with appropriate chunk_size and chunk_overlap\n",
        "# Experiment with different chunk sizes (e.g., 500, 1000, 1500 characters)\n",
        "\n",
        "text_splitter = RecursiveCharacterTextSplitter(\n",
        "    chunk_size=1000,\n",
        "    chunk_overlap=200,\n",
        "    length_function=len,\n",
        "    separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n",
        ")\n",
        "\n",
        "# Split the documents\n",
        "splits = text_splitter.split_documents(documents)\n",
        "print(f\"Split {len(documents)} documents into {len(splits)} chunks\")\n",
        "\n",
        "# Show sample chunk\n",
        "if splits:\n",
        "    print(f\"\\nSample chunk (first 200 characters):\")\n",
        "    print(splits[0].page_content[:200] + \"...\")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 4. Create Vector Store\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Vector store created and persisted to data/vectorstore\n",
            "Total vectors stored: 25\n"
          ]
        }
      ],
      "source": [
        "# Create a ChromaDB vector store\n",
        "# Initialize OpenAIEmbeddings\n",
        "# Create the vector store with the document chunks\n",
        "# Persist the vector store to disk for future use\n",
        "\n",
        "# Set up the persist directory\n",
        "persist_directory = \"data/vectorstore\"\n",
        "os.makedirs(persist_directory, exist_ok=True)\n",
        "\n",
        "# Initialize embeddings\n",
        "embeddings = OpenAIEmbeddings(\n",
        "    base_url=\"https://openai.vocareum.com/v1\",\n",
        "    api_key=os.getenv(\"VOCAREUM_API_KEY\")\n",
        ")\n",
        "\n",
        "# Create the vector store\n",
        "vectorstore = Chroma.from_documents(\n",
        "    documents=splits,\n",
        "    embedding=embeddings,\n",
        "    persist_directory=persist_directory\n",
        ")\n",
        "\n",
        "print(f\"Vector store created and persisted to {persist_directory}\")\n",
        "print(f\"Total vectors stored: {len(splits)}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 5. Test the RAG Pipeline\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 6,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "=== Testing Vector Search ===\n",
            "\n",
            "Query: 'electric vehicle charging tips'\n",
            "  Result 1: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "  Result 2: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "\n",
            "Query: 'thermostat optimization'\n",
            "  Result 1: # HVAC System Optimization Strategies\n",
            "\n",
            "## Temperature Management\n",
            "\n",
            "### Optimal Thermostat Settings\n",
            "- ...\n",
            "  Result 2: # HVAC System Optimization Strategies\n",
            "\n",
            "## Temperature Management\n",
            "\n",
            "### Optimal Thermostat Settings\n",
            "- ...\n",
            "\n",
            "Query: 'dishwasher energy saving'\n",
            "  Result 1: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n",
            "  Result 2: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n",
            "\n",
            "Query: 'solar power maximization'\n",
            "  Result 1: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "  Result 2: Large devices like electric vehicles, washing machines and dishwashers often support delayed start o...\n",
            "\n",
            "Query: 'HVAC system efficiency'\n",
            "  Result 1: ### Annual Professional Maintenance\n",
            "- Schedule professional HVAC inspection annually\n",
            "- Clean coils, ...\n",
            "  Result 2: ### Annual Professional Maintenance\n",
            "- Schedule professional HVAC inspection annually\n",
            "- Clean coils, ...\n",
            "\n",
            "Query: 'pool pump scheduling'\n",
            "  Result 1: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n",
            "  Result 2: Dishwasher Best Practices:\n",
            "- Only run when completely full\n",
            "- Use the energy-saving or eco mode when ...\n"
          ]
        }
      ],
      "source": [
        "# Test the search functionality\n",
        "# Try different queries related to energy optimization\n",
        "# Test queries like:\n",
        "# - \"electric vehicle charging tips\"\n",
        "# - \"thermostat optimization\"\n",
        "# - \"dishwasher energy saving\"\n",
        "# - \"solar power maximization\"\n",
        "\n",
        "test_queries = [\n",
        "    \"electric vehicle charging tips\",\n",
        "    \"thermostat optimization\",\n",
        "    \"dishwasher energy saving\",\n",
        "    \"solar power maximization\",\n",
        "    \"HVAC system efficiency\",\n",
        "    \"pool pump scheduling\"\n",
        "]\n",
        "\n",
        "print(\"=== Testing Vector Search ===\")\n",
        "for query in test_queries:\n",
        "    print(f\"\\nQuery: '{query}'\")\n",
        "    docs = vectorstore.similarity_search(query, k=2)\n",
        "    for i, doc in enumerate(docs):\n",
        "        print(f\"  Result {i+1}: {doc.page_content[:100]}...\")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 6. Test the Search Tool\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 7,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "=== Testing search_energy_tips Tool ===\n",
            "\n",
            "Query: 'electric vehicle charging'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n",
            "\n",
            "Query: 'thermostat settings'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n",
            "\n",
            "Query: 'dishwasher optimization'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n",
            "\n",
            "Query: 'solar power tips'\n",
            "  Error: Failed to search energy tips: Error code: 401 - {'error': {'message': 'Incorrect API key provided: voc-1540**************************************1279. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}\n"
          ]
        }
      ],
      "source": [
        "# Test the search_energy_tips tool from tools.py\n",
        "# Import and test the tool with various queries\n",
        "# Verify that it returns relevant results\n",
        "\n",
        "from tools import search_energy_tips\n",
        "\n",
        "# Test the search_energy_tips function\n",
        "print(\"=== Testing search_energy_tips Tool ===\")\n",
        "\n",
        "test_queries = [\n",
        "    \"electric vehicle charging\",\n",
        "    \"thermostat settings\",\n",
        "    \"dishwasher optimization\",\n",
        "    \"solar power tips\"\n",
        "]\n",
        "\n",
        "for query in test_queries:\n",
        "    print(f\"\\nQuery: '{query}'\")\n",
        "    result = search_energy_tips.invoke(\n",
        "        input={\n",
        "            \"query\": query, \n",
        "            \"max_results\": 3,\n",
        "        }\n",
        "    )\n",
        "    \n",
        "    if \"error\" in result:\n",
        "        print(f\"  Error: {result['error']}\")\n",
        "    else:\n",
        "        print(f\"  Found {result['total_results']} results\")\n",
        "        for i, tip in enumerate(result['tips']):\n",
        "            print(f\"    {i+1}. {tip['content'][:100]}...\")\n",
        "            print(f\"       Source: {tip['source']}\")\n",
        "            print(f\"       Relevance: {tip['relevance_score']}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.11.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}
</file_content>

<file_content path="master_project/03_run_and_evaluate.ipynb">
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "b8860961",
   "metadata": {},
   "source": [
    "# EcoHome Energy Advisor - Agent Run & Evaluation\\n\n",
    "\\n\n",
    "In this notebook, you'll run the Energy Advisor agent with various real-world scenarios and see how it helps customers optimize their energy usage.\\n\n",
    "\\n\n",
    "## Learning Objectives\\n\n",
    "- Create the agent's instructions\\n\n",
    "- Run the Energy Advisor with different types of questions\\n\n",
    "- Evaluate response quality and accuracy\\n\n",
    "- Measure tool usage effectiveness\\n\n",
    "- Identify areas for improvement\\n\n",
    "- Implement evaluation metrics\\n\n",
    "\\n\n",
    "## Evaluation Criteria\\n\n",
    "- **Accuracy**: Correct information and calculations\\n\n",
    "- **Relevance**: Responses address the user's question\\n\n",
    "- **Completeness**: Comprehensive answers with actionable advice\\n\n",
    "- **Tool Usage**: Appropriate use of available tools\\n\n",
    "- **Reasoning**: Clear explanation of recommendations\\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce6ffc7d",
   "metadata": {},
   "source": [
    "## 1. Import and Initialize"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "b989c804",
   "metadata": {},
   "outputs": [],
   "source": [
    "from datetime import datetime\n",
    "from agent import Agent"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "0d063734",
   "metadata": {},
   "outputs": [],
   "source": [
    "ECOHOME_SYSTEM_PROMPT = \"\"\"# EcoHome Energy Advisor: System Prompt\n",
    "\n",
    "## Role and Goal\n",
    "\n",
    "You are the EcoHome Energy Advisor, an advanced AI assistant from EcoHome Inc. Your primary goal is to help users optimize their home energy consumption, reduce costs, and minimize their environmental impact. You must provide accurate, data-driven, and actionable recommendations in a friendly, clear, and professional tone.\n",
    "\n",
    "## Step-by-Step Operation\n",
    "\n",
    "1.  **Analyze User Request**: Carefully review the user's question and any provided context (e.g., location, devices, preferences).\n",
    "2.  **Gather Data**: Use the available tools to collect real-time data, such as weather forecasts, electricity prices, and historical energy usage.\n",
    "3.  **Consult Knowledge Base**: Search the knowledge base for relevant energy-saving tips, best practices, and device-specific advice.\n",
    "4.  **Synthesize Findings**: Combine the collected data and knowledge to formulate a comprehensive and customized recommendation.\n",
    "5.  **Deliver Actionable Advice**: Present the final recommendation in a clear, structured, and easy-to-understand format. Include specific actions the user can take.\n",
    "\n",
    "## Key Capabilities\n",
    "\n",
    "*   **Energy Data Analysis**: Analyze historical energy usage and solar generation data to identify patterns and opportunities for improvement.\n",
    "*   **Weather-Informed Advice**: Use weather forecasts to provide proactive recommendations (e.g., pre-cooling your home before a heatwave).\n",
    "*   **Cost Optimization**: Factor in real-time electricity prices to recommend cost-effective energy schedules.\n",
    "*   **Knowledge Retrieval**: Access a rich knowledge base of energy-saving tips for various devices and scenarios.\n",
    "\n",
    "## Recommendation Instructions\n",
    "\n",
    "*   **Be Specific**: Provide concrete recommendations with clear, actionable steps (e.g., \"Set your thermostat to 78Â°F between 2 PM and 6 PM\").\n",
    "*   **Justify Recommendations**: Explain *why* you are making a recommendation, citing data from the tools (e.g., \"Electricity prices are highest during these hours\").\n",
    "*   **Format for Clarity**: Use headings, bullet points, and bold text to structure your response and improve readability.\n",
    "*   **Cite Sources**: When you use information from the knowledge base, cite the source document (e.g., \"Source: `tip_hvac_optimization.txt`\").\n",
    "\n",
    "## Example Questions\n",
    "\n",
    "*   \"When is the best time to charge my EV tomorrow to save money?\"\n",
    "*   \"How can I lower my air conditioning costs during the summer?\"\n",
    "*   \"What are some tips for reducing my dishwasher's energy consumption?\"\n",
    "*   \"How can I maximize my solar panel output on a cloudy day?\"\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "1aaa54a3",
   "metadata": {},
   "outputs": [],
   "source": [
    "ecohome_agent = Agent(\n",
    "    instructions=ECOHOME_SYSTEM_PROMPT,\n",
    "    model=\"gpt-4o-mini\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "05d2730e",
   "metadata": {},
   "source": [
    "## 2. Define Test Cases"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "aefe0d45",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_cases = [\n",
    "    {\n",
    "        \"id\": \"ev_charging_cost\",\n",
    "        \"question\": \"When is the cheapest time to charge my EV tomorrow?\",\n",
    "        \"expected_tools\": [\"get_electricity_prices\"],\n",
    "        \"expected_response\": \"The response should recommend charging during off-peak hours and mention the specific time range.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"ev_charging_solar\",\n",
    "        \"question\": \"I want to charge my EV tomorrow using only solar power. When should I do it?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\"],\n",
    "        \"expected_response\": \"The response should recommend charging during peak solar generation hours and consider cloud cover.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"hvac_cost_savings\",\n",
    "        \"question\": \"How can I save money on my AC bill this summer?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide tips on thermostat settings, maintenance, and using fans, citing the HVAC optimization document.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"hvac_pre_cooling\",\n",
    "        \"question\": \"There is a heatwave tomorrow. How should I set my thermostat?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\", \"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should recommend pre-cooling the house before the peak heat and adjusting the thermostat during the day.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"appliance_scheduling\",\n",
    "        \"question\": \"When is the best time to run my dishwasher and washing machine?\",\n",
    "        \"expected_tools\": [\"get_electricity_prices\"],\n",
    "        \"expected_response\": \"The response should recommend running appliances during off-peak hours to save on electricity costs.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"solar_maximization_cloudy\",\n",
    "        \"question\": \"It's going to be cloudy tomorrow. How can I maximize my solar panel output?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\", \"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide tips on cleaning panels and reducing consumption during cloudy periods.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"solar_maximization_sunny\",\n",
    "        \"question\": \"It will be sunny all week. How can I make the most of my solar panels?\",\n",
    "        \"expected_tools\": [\"get_weather_forecast\", \"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should recommend shifting energy-intensive tasks to peak solar hours.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"general_energy_savings\",\n",
    "        \"question\": \"What are some general tips for saving energy at home?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide a variety of tips from the knowledge base, covering different aspects of home energy use.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"device_best_practices\",\n",
    "        \"question\": \"What are the best practices for using my refrigerator efficiently?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide specific tips for refrigerator use, citing the device best practices document.\"\n",
    "    },\n",
    "    {\n",
    "        \"id\": \"seasonal_energy_management\",\n",
    "        \"question\": \"How should my energy habits change from winter to summer?\",\n",
    "        \"expected_tools\": [\"search_energy_tips\"],\n",
    "        \"expected_response\": \"The response should provide seasonal tips, such as adjusting thermostat settings and using appliances differently in different seasons, citing the seasonal energy management document.\"\n",
    "    }\n",
    "]\n",
    "\n",
    "if len(test_cases) < 10:\n",
    "    raise ValueError(\"You MUST have at least 10 test cases\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2cdde81",
   "metadata": {},
   "source": [
    "## 3. Run Agent Tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "b8eb83e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "CONTEXT = \"Location: San Francisco, CA\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "e9dc82e8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Running Agent Tests ===\n",
      "\n",
      "Test 1: ev_charging_cost\n",
      "Question: When is the cheapest time to charge my EV tomorrow?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 2: ev_charging_solar\n",
      "Question: I want to charge my EV tomorrow using only solar power. When should I do it?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 3: hvac_cost_savings\n",
      "Question: How can I save money on my AC bill this summer?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 4: hvac_pre_cooling\n",
      "Question: There is a heatwave tomorrow. How should I set my thermostat?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 5: appliance_scheduling\n",
      "Question: When is the best time to run my dishwasher and washing machine?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 6: solar_maximization_cloudy\n",
      "Question: It's going to be cloudy tomorrow. How can I maximize my solar panel output?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 7: solar_maximization_sunny\n",
      "Question: It will be sunny all week. How can I make the most of my solar panels?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 8: general_energy_savings\n",
      "Question: What are some general tips for saving energy at home?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 9: device_best_practices\n",
      "Question: What are the best practices for using my refrigerator efficiently?\n",
      "--------------------------------------------------\n",
      "\n",
      "Test 10: seasonal_energy_management\n",
      "Question: How should my energy habits change from winter to summer?\n",
      "--------------------------------------------------\n",
      "\n",
      "Completed 10 tests\n"
     ]
    }
   ],
   "source": [
    "print(\"=== Running Agent Tests ===\")\n",
    "test_results = []\n",
    "\n",
    "for i, test_case in enumerate(test_cases):\n",
    "    print(f\"\\nTest {i+1}: {test_case['id']}\")\n",
    "    print(f\"Question: {test_case['question']}\")\n",
    "    print(\"-\" * 50)\n",
    "    \n",
    "    try:\n",
    "        response = ecohome_agent.invoke(\n",
    "            question=test_case['question'],\n",
    "            context=CONTEXT\n",
    "        )\n",
    "        \n",
    "        result = {\n",
    "            'test_id': test_case['id'],\n",
    "            'question': test_case['question'],\n",
    "            'response': response,\n",
    "            'expected_tools': test_case['expected_tools'],\n",
    "            'expected_response': test_case['expected_response'],\n",
    "            'timestamp': datetime.now().isoformat()\n",
    "        }\n",
    "        test_results.append(result)\n",
    "                \n",
    "    except Exception as e:\n",
    "        print(f\"Error: {e}\")\n",
    "        result = {\n",
    "            'test_id': test_case['id'],\n",
    "            'question': test_case['question'],\n",
    "            'response': f\"Error: {str(e)}\",\n",
    "            'expected_tools': test_case['expected_tools'],\n",
    "            'expected_response': test_case['expected_response'],\n",
    "            'timestamp': datetime.now().isoformat(),\n",
    "            'error': str(e)\n",
    "        }\n",
    "        test_results.append(result)\n",
    "\n",
    "print(f\"\\nCompleted {len(test_results)} tests\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5760814c",
   "metadata": {},
   "source": [
    "## 4. Evaluate Responses"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "1da0640e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def evaluate_response(question, final_response, expected_response):\n",
    "    \"\"\"\n",
    "    Evaluate a single agent response based on a set of criteria.\n",
    "    \n",
    "    Metrics:\n",
    "    - ACCURACY: Based on keywords from expected response.\n",
    "    - RELEVANCE: Is the response related to the question? (simple check)\n",
    "    - COMPLETENESS: Does the response provide justification? (e.g., 'because')\n",
    "    - USEFULNESS: Does the response give actionable advice? (e.g., 'recommend')\n",
    "    \"\"\"\n",
    "    \n",
    "    scores = {}\n",
    "    feedback = []\n",
    "    final_response_lower = final_response.lower()\n",
    "    question_lower = question.lower()\n",
    "\n",
    "    # RELEVANCE\n",
    "    question_words = set(question_lower.split())\n",
    "    if any(word in final_response_lower for word in question_words):\n",
    "        scores['RELEVANCE'] = 1.0\n",
    "        feedback.append(\"Response is relevant to the question.\")\n",
    "    else:\n",
    "        scores['RELEVANCE'] = 0.0\n",
    "        feedback.append(\"Response may not be relevant.\")\n",
    "\n",
    "    # ACCURACY & COMPLETENESS (using expected_response as keywords)\n",
    "    expected_keywords = set(expected_response.lower().replace('.', '').split())\n",
    "    found_keywords = [kw for kw in expected_keywords if kw in final_response_lower]\n",
    "    accuracy_score = len(found_keywords) / len(expected_keywords) if expected_keywords else 0\n",
    "    scores['ACCURACY'] = accuracy_score\n",
    "    scores['COMPLETENESS'] = accuracy_score  # Use same score as a proxy\n",
    "    if accuracy_score > 0.7:\n",
    "        feedback.append(f\"Response contains {len(found_keywords)}/{len(expected_keywords)} expected keywords.\")\n",
    "    else:\n",
    "        feedback.append(f\"Response is missing many expected keywords (found {len(found_keywords)}/{len(expected_keywords)}).\")\n",
    "\n",
    "    # USEFULNESS\n",
    "    if \"recommend\" in final_response_lower or \"you should\" in final_response_lower:\n",
    "        scores['USEFULNESS'] = 1.0\n",
    "        feedback.append(\"Response provides actionable advice.\")\n",
    "    else:\n",
    "        scores['USEFULNESS'] = 0.0\n",
    "        feedback.append(\"Response could be more actionable.\")\n",
    "        \n",
    "    overall_score = sum(scores.values()) / len(scores)\n",
    "\n",
    "    return {\n",
    "        \"overall_score\": overall_score,\n",
    "        \"metrics\": scores,\n",
    "        \"feedback\": \" \".join(feedback)\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "7e0dc154",
   "metadata": {},
   "outputs": [],
   "source": [
    "def evaluate_tool_usage(messages, expected_tools):\n",
    "    \"\"\"\n",
    "    Evaluate if the right tools were used with comprehensive metrics.\n",
    "    \n",
    "    Metrics:\n",
    "    - Tool Appropriateness: Were the right tools selected for the task?\n",
    "    - Tool Completeness: Were all necessary tools used?\n",
    "    \n",
    "    Returns comprehensive feedback for tool usage evaluation.\n",
    "    \"\"\"\n",
    "    \n",
    "    used_tools = set()\n",
    "    for message in messages:\n",
    "        if hasattr(message, 'tool_calls') and message.tool_calls:\n",
    "            for tool_call in message.tool_calls:\n",
    "                used_tools.add(tool_call[\"name\"])\n",
    "    \n",
    "    expected_tools = set(expected_tools)\n",
    "    \n",
    "    correct_tools = used_tools.intersection(expected_tools)\n",
    "    missed_tools = expected_tools.difference(used_tools)\n",
    "    extra_tools = used_tools.difference(expected_tools)\n",
    "    \n",
    "    # Calculate metrics\n",
    "    # Tool Appropriateness: Ratio of correct tools to used tools (measures precision)\n",
    "    # Were the right tools selected? Penalizes using unnecessary/wrong tools\n",
    "    if len(used_tools) > 0:\n",
    "        tool_appropriateness = len(correct_tools) / len(used_tools)\n",
    "    else:\n",
    "        # If no tools were used but tools were expected, appropriateness is 0\n",
    "        tool_appropriateness = 0.0 if len(expected_tools) > 0 else 1.0\n",
    "    \n",
    "    # Tool Completeness: Ratio of correct tools to expected tools (measures recall)\n",
    "    # Were all necessary tools used? Penalizes missing required tools\n",
    "    if len(expected_tools) > 0:\n",
    "        tool_completeness = len(correct_tools) / len(expected_tools)\n",
    "    else:\n",
    "        # If no tools were expected, completeness is 1.0\n",
    "        tool_completeness = 1.0\n",
    "    \n",
    "    # Overall tool usage score (F1-like score combining appropriateness and completeness)\n",
    "    if tool_appropriateness + tool_completeness > 0:\n",
    "        overall_tool_score = 2 * (tool_appropriateness * tool_completeness) / (tool_appropriateness + tool_completeness)\n",
    "    else:\n",
    "        overall_tool_score = 0.0\n",
    "    \n",
    "    # Generate comprehensive feedback\n",
    "    feedback = []\n",
    "    \n",
    "    if len(correct_tools) == len(expected_tools) and len(extra_tools) == 0:\n",
    "        feedback.append(\"Perfect tool selection! All expected tools were used and no unnecessary tools were called.\")\n",
    "    else:\n",
    "        # Feedback on appropriateness\n",
    "        if tool_appropriateness >= 0.9:\n",
    "            feedback.append(f\"Excellent tool appropriateness ({tool_appropriateness:.0%}): Agent selected the right tools.\")\n",
    "        elif tool_appropriateness >= 0.7:\n",
    "            feedback.append(f\"Good tool appropriateness ({tool_appropriateness:.0%}): Most tools selected were correct.\")\n",
    "        elif tool_appropriateness >= 0.5:\n",
    "            feedback.append(f\"Fair tool appropriateness ({tool_appropriateness:.0%}): Some incorrect tools were used.\")\n",
    "        else:\n",
    "            feedback.append(f\"Poor tool appropriateness ({tool_appropriateness:.0%}): Many incorrect or unnecessary tools were used.\")\n",
    "        \n",
    "        # Feedback on completeness\n",
    "        if tool_completeness >= 0.9:\n",
    "            feedback.append(f\"Excellent tool completeness ({tool_completeness:.0%}): Agent used almost all necessary tools.\")\n",
    "        elif tool_completeness >= 0.7:\n",
    "            feedback.append(f\"Good tool completeness ({tool_completeness:.0%}): Most necessary tools were used.\")\n",
    "        elif tool_completeness >= 0.5:\n",
    "            feedback.append(f\"Fair tool completeness ({tool_completeness:.0%}): Some necessary tools were missed.\")\n",
    "        else:\n",
    "            feedback.append(f\"Poor tool completeness ({tool_completeness:.0%}): Many necessary tools were not used.\")\n",
    "    \n",
    "    # Specific feedback on tool usage\n",
    "    if len(correct_tools) > 0:\n",
    "        feedback.append(f\"Correctly used: {', '.join(sorted(correct_tools))}.\")\n",
    "    \n",
    "    if len(missed_tools) > 0:\n",
    "        feedback.append(f\"Missed tools: {', '.join(sorted(missed_tools))}.\")\n",
    "    \n",
    "    if len(extra_tools) > 0:\n",
    "        feedback.append(f\"Extra tools used: {', '.join(sorted(extra_tools))}.\")\n",
    "    \n",
    "    return {\n",
    "        \"score\": overall_tool_score,\n",
    "        \"metrics\": {\n",
    "            \"TOOL_APPROPRIATENESS\": tool_appropriateness,\n",
    "            \"TOOL_COMPLETENESS\": tool_completeness\n",
    "        },\n",
    "        \"used_tools\": list(used_tools),\n",
    "        \"expected_tools\": list(expected_tools),\n",
    "        \"correct_tools\": list(correct_tools),\n",
    "        \"missed_tools\": list(missed_tools),\n",
    "        \"extra_tools\": list(extra_tools),\n",
    "        \"feedback\": \" \".join(feedback)\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "9c3df271",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_evaluation_report(test_results):\n",
    "    \"\"\"\n",
    "    Generate a comprehensive evaluation report based on execution and metrics.\n",
    "\n",
    "    This function calculates overall scores and metrics, identifies strengths and\n",
    "    weaknesses, and provides recommendations for improvement.\n",
    "    \"\"\"\n",
    "\n",
    "    # Initialize metric accumulators\n",
    "    total_response_score = 0\n",
    "    total_tool_usage_score = 0\n",
    "    total_relevance = 0\n",
    "    total_accuracy = 0\n",
    "    total_completeness = 0\n",
    "    total_usefulness = 0\n",
    "    total_tool_appropriateness = 0\n",
    "    total_tool_completeness = 0\n",
    "\n",
    "    # Collect detailed evaluation data\n",
    "    evaluations = []\n",
    "\n",
    "    for result in test_results:\n",
    "        if 'error' in result:\n",
    "            continue\n",
    "\n",
    "        final_response_content = result[\"response\"][\"messages\"][-1].content\n",
    "        response_eval = evaluate_response(\n",
    "            result[\"question\"],\n",
    "            final_response_content,\n",
    "            result[\"expected_response\"]\n",
    "        )\n",
    "        tool_eval = evaluate_tool_usage(\n",
    "            result[\"response\"][\"messages\"],\n",
    "            result[\"expected_tools\"]\n",
    "        )\n",
    "\n",
    "        evaluations.append({\n",
    "            'test_id': result['test_id'],\n",
    "            'question': result['question'],\n",
    "            'response_eval': response_eval,\n",
    "            'tool_eval': tool_eval\n",
    "        })\n",
    "\n",
    "        total_response_score += response_eval[\"overall_score\"]\n",
    "        total_tool_usage_score += tool_eval[\"score\"]\n",
    "        total_relevance += response_eval[\"metrics\"][\"RELEVANCE\"]\n",
    "        total_accuracy += response_eval[\"metrics\"][\"ACCURACY\"]\n",
    "        total_completeness += response_eval[\"metrics\"][\"COMPLETENESS\"]\n",
    "        total_usefulness += response_eval[\"metrics\"][\"USEFULNESS\"]\n",
    "        total_tool_appropriateness += tool_eval[\"metrics\"][\"TOOL_APPROPRIATENESS\"]\n",
    "        total_tool_completeness += tool_eval[\"metrics\"][\"TOOL_COMPLETENESS\"]\n",
    "\n",
    "    num_successful_tests = len(evaluations)\n",
    "\n",
    "    if num_successful_tests == 0:\n",
    "        return \"# Evaluation Report\\n\\nNo successful test cases to evaluate.\"\n",
    "\n",
    "    # Calculate overall metrics\n",
    "    avg_response_score = total_response_score / num_successful_tests\n",
    "    avg_tool_usage_score = total_tool_usage_score / num_successful_tests\n",
    "    avg_relevance = total_relevance / num_successful_tests\n",
    "    avg_accuracy = total_accuracy / num_successful_tests\n",
    "    avg_completeness = total_completeness / num_successful_tests\n",
    "    avg_usefulness = total_usefulness / num_successful_tests\n",
    "    avg_tool_appropriateness = total_tool_appropriateness / num_successful_tests\n",
    "    avg_tool_completeness = total_tool_completeness / num_successful_tests\n",
    "\n",
    "    # Calculate weighted overall score (40% response quality, 30% tool usage, 30% individual metrics)\n",
    "    overall_score = (\n",
    "        avg_response_score * 0.4 +\n",
    "        avg_tool_usage_score * 0.3 +\n",
    "        (avg_relevance + avg_accuracy + avg_completeness + avg_usefulness) / 4 * 0.3\n",
    "    )\n",
    "\n",
    "    # Build the report\n",
    "    report = \"# EcoHome Energy Advisor: Comprehensive Evaluation Report\\n\\n\"\n",
    "\n",
    "    # Executive Summary\n",
    "    report += \"## Executive Summary\\n\\n\"\n",
    "    report += f\"This report evaluates the performance of the EcoHome Energy Advisor across {len(test_results)} test cases \"\n",
    "    report += f\"({num_successful_tests} successful, {len(test_results) - num_successful_tests} failed).\\n\\n\"\n",
    "\n",
    "    # Overall Scores and Metrics\n",
    "    report += \"## Overall Scores and Metrics\\n\\n\"\n",
    "    report += \"### Primary Metrics\\n\"\n",
    "    report += f\"- **Overall Score**: {overall_score:.2%} ({_get_grade(overall_score)})\\n\"\n",
    "    report += f\"- **Average Response Quality**: {avg_response_score:.2%}\\n\"\n",
    "    report += f\"- **Average Tool Usage**: {avg_tool_usage_score:.2%}\\n\\n\"\n",
    "\n",
    "    report += \"### Detailed Metrics\\n\"\n",
    "    report += f\"- **Relevance**: {avg_relevance:.2%} - How well responses address user questions\\n\"\n",
    "    report += f\"- **Accuracy**: {avg_accuracy:.2%} - Correctness of information and calculations\\n\"\n",
    "    report += f\"- **Completeness**: {avg_completeness:.2%} - Comprehensiveness of answers\\n\"\n",
    "    report += f\"- **Usefulness**: {avg_usefulness:.2%} - Actionability of recommendations\\n\"\n",
    "    report += f\"- **Tool Appropriateness**: {avg_tool_appropriateness:.2%} - Were the right tools selected?\\n\"\n",
    "    report += f\"- **Tool Completeness**: {avg_tool_completeness:.2%} - Were all necessary tools used?\\n\\n\"\n",
    "\n",
    "    # Performance Distribution\n",
    "    report += \"### Performance Distribution\\n\"\n",
    "    excellent = sum(1 for e in evaluations if e['response_eval']['overall_score'] >= 0.9)\n",
    "    good = sum(1 for e in evaluations if 0.7 <= e['response_eval']['overall_score'] < 0.9)\n",
    "    fair = sum(1 for e in evaluations if 0.5 <= e['response_eval']['overall_score'] < 0.7)\n",
    "    poor = sum(1 for e in evaluations if e['response_eval']['overall_score'] < 0.5)\n",
    "\n",
    "    report += f\"- **Excellent (90%+)**: {excellent} tests\\n\"\n",
    "    report += f\"- **Good (70-89%)**: {good} tests\\n\"\n",
    "    report += f\"- **Fair (50-69%)**: {fair} tests\\n\"\n",
    "    report += f\"- **Poor (<50%)**: {poor} tests\\n\\n\"\n",
    "\n",
    "    # Strengths and Weaknesses\n",
    "    report += \"## Strengths and Weaknesses\\n\\n\"\n",
    "    report += \"### Strengths\\n\"\n",
    "\n",
    "    strengths = []\n",
    "    if avg_relevance >= 0.85:\n",
    "        strengths.append(f\"**High Relevance** ({avg_relevance:.0%}): Agent consistently addresses user questions directly\")\n",
    "    if avg_tool_usage_score >= 0.80:\n",
    "        strengths.append(f\"**Effective Tool Usage** ({avg_tool_usage_score:.0%}): Agent selects and uses appropriate tools\")\n",
    "    if avg_usefulness >= 0.80:\n",
    "        strengths.append(f\"**Actionable Recommendations** ({avg_usefulness:.0%}): Responses provide clear, actionable advice\")\n",
    "    if avg_accuracy >= 0.70:\n",
    "        strengths.append(f\"**Good Accuracy** ({avg_accuracy:.0%}): Information and recommendations are generally accurate\")\n",
    "    if avg_completeness >= 0.70:\n",
    "        strengths.append(f\"**Comprehensive Responses** ({avg_completeness:.0%}): Answers are thorough and complete\")\n",
    "    if avg_tool_appropriateness >= 0.85:\n",
    "        strengths.append(f\"**Excellent Tool Selection** ({avg_tool_appropriateness:.0%}): Agent consistently chooses appropriate tools\")\n",
    "    if avg_tool_completeness >= 0.85:\n",
    "        strengths.append(f\"**Complete Tool Usage** ({avg_tool_completeness:.0%}): Agent uses all necessary tools\")\n",
    "\n",
    "    if strengths:\n",
    "        for strength in strengths:\n",
    "            report += f\"- {strength}\\n\"\n",
    "    else:\n",
    "        report += \"- No significant strengths identified in current evaluation\\n\"\n",
    "\n",
    "    report += \"\\n### Weaknesses\\n\"\n",
    "\n",
    "    weaknesses = []\n",
    "    if avg_relevance < 0.70:\n",
    "        weaknesses.append(f\"**Low Relevance** ({avg_relevance:.0%}): Responses often miss the core question\")\n",
    "    if avg_tool_usage_score < 0.70:\n",
    "        weaknesses.append(f\"**Poor Tool Selection** ({avg_tool_usage_score:.0%}): Agent frequently uses incorrect or missing tools\")\n",
    "    if avg_usefulness < 0.70:\n",
    "        weaknesses.append(f\"**Lack of Actionability** ({avg_usefulness:.0%}): Recommendations are not sufficiently actionable\")\n",
    "    if avg_accuracy < 0.60:\n",
    "        weaknesses.append(f\"**Accuracy Issues** ({avg_accuracy:.0%}): Responses lack expected information or contain errors\")\n",
    "    if avg_completeness < 0.60:\n",
    "        weaknesses.append(f\"**Incomplete Responses** ({avg_completeness:.0%}): Answers lack necessary detail\")\n",
    "    if avg_tool_appropriateness < 0.70:\n",
    "        weaknesses.append(f\"**Poor Tool Appropriateness** ({avg_tool_appropriateness:.0%}): Agent often selects wrong or unnecessary tools\")\n",
    "    if avg_tool_completeness < 0.70:\n",
    "        weaknesses.append(f\"**Incomplete Tool Usage** ({avg_tool_completeness:.0%}): Agent frequently misses necessary tools\")\n",
    "\n",
    "    if weaknesses:\n",
    "        for weakness in weaknesses:\n",
    "            report += f\"- {weakness}\\n\"\n",
    "    else:\n",
    "        report += \"- No significant weaknesses identified in current evaluation\\n\"\n",
    "\n",
    "    # Tool Usage Analysis\n",
    "    report += \"\\n### Tool Usage Analysis\\n\"\n",
    "    all_used_tools = set()\n",
    "    all_missed_tools = set()\n",
    "    for e in evaluations:\n",
    "        all_used_tools.update(e['tool_eval']['used_tools'])\n",
    "        all_missed_tools.update(e['tool_eval']['missed_tools'])\n",
    "\n",
    "    report += f\"- **Tools Successfully Used**: {', '.join(sorted(all_used_tools)) if all_used_tools else 'None'}\\n\"\n",
    "    report += f\"- **Frequently Missed Tools**: {', '.join(sorted(all_missed_tools)) if all_missed_tools else 'None'}\\n\"\n",
    "\n",
    "    # Recommendations for Improvement\n",
    "    report += \"\\n## Recommendations for Improvement\\n\\n\"\n",
    "\n",
    "    recommendations = []\n",
    "\n",
    "    # Priority recommendations based on weaknesses\n",
    "    if avg_accuracy < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'HIGH',\n",
    "            'area': 'Response Accuracy',\n",
    "            'recommendation': 'Review and enhance the system prompt to ensure agent responses align with expected information',\n",
    "            'action': 'Update ECOHOME_SYSTEM_PROMPT with more specific examples and guidelines'\n",
    "        })\n",
    "\n",
    "    if avg_tool_usage_score < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'HIGH',\n",
    "            'area': 'Tool Selection',\n",
    "            'recommendation': 'Improve tool descriptions and add examples to help agent select appropriate tools',\n",
    "            'action': 'Review tool definitions in agent configuration and add usage examples'\n",
    "        })\n",
    "\n",
    "    if avg_usefulness < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'MEDIUM',\n",
    "            'area': 'Actionability',\n",
    "            'recommendation': 'Enhance prompts to emphasize providing specific, actionable recommendations',\n",
    "            'action': 'Add explicit instructions for action-oriented responses in system prompt'\n",
    "        })\n",
    "\n",
    "    if avg_completeness < 0.70:\n",
    "        recommendations.append({\n",
    "            'priority': 'MEDIUM',\n",
    "            'area': 'Response Completeness',\n",
    "            'recommendation': 'Ensure agent provides comprehensive answers covering all aspects of user questions',\n",
    "            'action': 'Add checklist in system prompt for complete responses'\n",
    "        })\n",
    "\n",
    "    if poor > num_successful_tests * 0.3:\n",
    "        recommendations.append({\n",
    "            'priority': 'HIGH',\n",
    "            'area': 'Overall Performance',\n",
    "            'recommendation': f'{poor} tests performed poorly (<50% score). Investigate failing test cases',\n",
    "            'action': 'Review individual test case results and identify common failure patterns'\n",
    "        })\n",
    "\n",
    "    # General recommendations\n",
    "    recommendations.append({\n",
    "        'priority': 'LOW',\n",
    "        'area': 'Testing Coverage',\n",
    "        'recommendation': 'Expand test cases to cover edge cases and more diverse scenarios',\n",
    "        'action': 'Add 5-10 additional test cases covering unusual or complex queries'\n",
    "    })\n",
    "\n",
    "    recommendations.append({\n",
    "        'priority': 'LOW',\n",
    "        'area': 'Continuous Improvement',\n",
    "        'recommendation': 'Implement automated evaluation pipeline for regular performance monitoring',\n",
    "        'action': 'Set up scheduled test runs and track metrics over time'\n",
    "    })\n",
    "\n",
    "    # Sort by priority\n",
    "    priority_order = {'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}\n",
    "    recommendations.sort(key=lambda x: priority_order[x['priority']])\n",
    "\n",
    "    for rec in recommendations:\n",
    "        report += f\"### {rec['priority']} Priority: {rec['area']}\\n\"\n",
    "        report += f\"**Recommendation**: {rec['recommendation']}\\n\\n\"\n",
    "        report += f\"**Action**: {rec['action']}\\n\\n\"\n",
    "\n",
    "    # Detailed Test Results\n",
    "    report += \"## Detailed Test Results\\n\\n\"\n",
    "\n",
    "    for eval_data in evaluations:\n",
    "        report += f\"### Test Case: {eval_data['test_id']}\\n\"\n",
    "        report += f\"**Question**: {eval_data['question']}\\n\\n\"\n",
    "        \n",
    "        report += f\"**Response Score**: {eval_data['response_eval']['overall_score']:.2f} | \"\n",
    "        report += f\"**Tool Usage Score**: {eval_data['tool_eval']['score']:.2f}\\n\\n\"\n",
    "        \n",
    "        report += f\"**Feedback**: {eval_data['response_eval']['feedback']}\\n\\n\"\n",
    "        \n",
    "        report += \"**Details**\\n\\n\"\n",
    "        report += f\"**Used Tools**: {', '.join(eval_data['tool_eval']['used_tools']) if eval_data['tool_eval']['used_tools'] else '[]'} | \"\n",
    "        report += f\"**Expected Tools**: {', '.join(eval_data['tool_eval']['expected_tools'])} | \"\n",
    "        report += f\"**Correct Tools**: {', '.join(eval_data['tool_eval']['correct_tools']) if eval_data['tool_eval']['correct_tools'] else '[]'} | \"\n",
    "        report += f\"**Missed Tools**: {', '.join(eval_data['tool_eval']['missed_tools']) if eval_data['tool_eval']['missed_tools'] else '[]'} | \"\n",
    "        report += f\"**Extra Tools**: {', '.join(eval_data['tool_eval']['extra_tools']) if eval_data['tool_eval']['extra_tools'] else '[]'}\\n\\n\"\n",
    "        \n",
    "        report += f\"**Tool Usage Feedback**: {eval_data['tool_eval']['feedback']}\\n\\n\"\n",
    "        \n",
    "        report += \"---\\n\\n\"\n",
    "\n",
    "    return report\n",
    "\n",
    "def _get_grade(score):\n",
    "    \"\"\"Helper function to convert score to letter grade\"\"\"\n",
    "    if score >= 0.90:\n",
    "        return \"A\"\n",
    "    elif score >= 0.80:\n",
    "        return \"B\"\n",
    "    elif score >= 0.70:\n",
    "        return \"C\"\n",
    "    elif score >= 0.60:\n",
    "        return \"D\"\n",
    "    else:\n",
    "        return \"F\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "8eeb59ba",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/markdown": [
       "# EcoHome Energy Advisor: Comprehensive Evaluation Report\n",
       "\n",
       "## Executive Summary\n",
       "\n",
       "This report evaluates the performance of the EcoHome Energy Advisor across 10 test cases (10 successful, 0 failed).\n",
       "\n",
       "## Overall Scores and Metrics\n",
       "\n",
       "### Primary Metrics\n",
       "- **Overall Score**: 64.73% (D)\n",
       "- **Average Response Quality**: 66.05%\n",
       "- **Average Tool Usage**: 61.67%\n",
       "\n",
       "### Detailed Metrics\n",
       "- **Relevance**: 100.00% - How well responses address user questions\n",
       "- **Accuracy**: 57.10% - Correctness of information and calculations\n",
       "- **Completeness**: 57.10% - Comprehensiveness of answers\n",
       "- **Usefulness**: 50.00% - Actionability of recommendations\n",
       "- **Tool Appropriateness**: 65.00% - Were the right tools selected?\n",
       "- **Tool Completeness**: 65.00% - Were all necessary tools used?\n",
       "\n",
       "### Performance Distribution\n",
       "- **Excellent (90%+)**: 1 tests\n",
       "- **Good (70-89%)**: 4 tests\n",
       "- **Fair (50-69%)**: 2 tests\n",
       "- **Poor (<50%)**: 3 tests\n",
       "\n",
       "## Strengths and Weaknesses\n",
       "\n",
       "### Strengths\n",
       "- **High Relevance** (100%): Agent consistently addresses user questions directly\n",
       "\n",
       "### Weaknesses\n",
       "- **Poor Tool Selection** (62%): Agent frequently uses incorrect or missing tools\n",
       "- **Lack of Actionability** (50%): Recommendations are not sufficiently actionable\n",
       "- **Accuracy Issues** (57%): Responses lack expected information or contain errors\n",
       "- **Incomplete Responses** (57%): Answers lack necessary detail\n",
       "- **Poor Tool Appropriateness** (65%): Agent often selects wrong or unnecessary tools\n",
       "- **Incomplete Tool Usage** (65%): Agent frequently misses necessary tools\n",
       "\n",
       "### Tool Usage Analysis\n",
       "- **Tools Successfully Used**: get_electricity_prices, get_weather_forecast, query_solar_generation, search_energy_tips\n",
       "- **Frequently Missed Tools**: search_energy_tips\n",
       "\n",
       "## Recommendations for Improvement\n",
       "\n",
       "### HIGH Priority: Response Accuracy\n",
       "**Recommendation**: Review and enhance the system prompt to ensure agent responses align with expected information\n",
       "\n",
       "**Action**: Update ECOHOME_SYSTEM_PROMPT with more specific examples and guidelines\n",
       "\n",
       "### HIGH Priority: Tool Selection\n",
       "**Recommendation**: Improve tool descriptions and add examples to help agent select appropriate tools\n",
       "\n",
       "**Action**: Review tool definitions in agent configuration and add usage examples\n",
       "\n",
       "### MEDIUM Priority: Actionability\n",
       "**Recommendation**: Enhance prompts to emphasize providing specific, actionable recommendations\n",
       "\n",
       "**Action**: Add explicit instructions for action-oriented responses in system prompt\n",
       "\n",
       "### MEDIUM Priority: Response Completeness\n",
       "**Recommendation**: Ensure agent provides comprehensive answers covering all aspects of user questions\n",
       "\n",
       "**Action**: Add checklist in system prompt for complete responses\n",
       "\n",
       "### LOW Priority: Testing Coverage\n",
       "**Recommendation**: Expand test cases to cover edge cases and more diverse scenarios\n",
       "\n",
       "**Action**: Add 5-10 additional test cases covering unusual or complex queries\n",
       "\n",
       "### LOW Priority: Continuous Improvement\n",
       "**Recommendation**: Implement automated evaluation pipeline for regular performance monitoring\n",
       "\n",
       "**Action**: Set up scheduled test runs and track metrics over time\n",
       "\n",
       "## Detailed Test Results\n",
       "\n",
       "### Test Case: ev_charging_cost\n",
       "**Question**: When is the cheapest time to charge my EV tomorrow?\n",
       "\n",
       "**Response Score**: 0.81 | **Tool Usage Score**: 1.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 8/13). Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_electricity_prices | **Expected Tools**: get_electricity_prices | **Correct Tools**: get_electricity_prices | **Missed Tools**: [] | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Perfect tool selection! All expected tools were used and no unnecessary tools were called. Correctly used: get_electricity_prices.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: ev_charging_solar\n",
       "**Question**: I want to charge my EV tomorrow using only solar power. When should I do it?\n",
       "\n",
       "**Response Score**: 0.86 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response contains 10/14 expected keywords. Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: query_solar_generation, get_weather_forecast | **Expected Tools**: get_weather_forecast | **Correct Tools**: get_weather_forecast | **Missed Tools**: [] | **Extra Tools**: query_solar_generation\n",
       "\n",
       "**Tool Usage Feedback**: Fair tool appropriateness (50%): Some incorrect tools were used. Excellent tool completeness (100%): Agent used almost all necessary tools. Correctly used: get_weather_forecast. Extra tools used: query_solar_generation.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: hvac_cost_savings\n",
       "**Question**: How can I save money on my AC bill this summer?\n",
       "\n",
       "**Response Score**: 0.41 | **Tool Usage Score**: 0.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 5/16). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast, get_electricity_prices | **Expected Tools**: search_energy_tips | **Correct Tools**: [] | **Missed Tools**: search_energy_tips | **Extra Tools**: get_weather_forecast, get_electricity_prices\n",
       "\n",
       "**Tool Usage Feedback**: Poor tool appropriateness (0%): Many incorrect or unnecessary tools were used. Poor tool completeness (0%): Many necessary tools were not used. Missed tools: search_energy_tips. Extra tools used: get_electricity_prices, get_weather_forecast.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: hvac_pre_cooling\n",
       "**Question**: There is a heatwave tomorrow. How should I set my thermostat?\n",
       "\n",
       "**Response Score**: 0.86 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response contains 10/14 expected keywords. Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast | **Expected Tools**: get_weather_forecast, search_energy_tips | **Correct Tools**: get_weather_forecast | **Missed Tools**: search_energy_tips | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Excellent tool appropriateness (100%): Agent selected the right tools. Fair tool completeness (50%): Some necessary tools were missed. Correctly used: get_weather_forecast. Missed tools: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: appliance_scheduling\n",
       "**Question**: When is the best time to run my dishwasher and washing machine?\n",
       "\n",
       "**Response Score**: 0.93 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response contains 12/14 expected keywords. Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast, get_electricity_prices | **Expected Tools**: get_electricity_prices | **Correct Tools**: get_electricity_prices | **Missed Tools**: [] | **Extra Tools**: get_weather_forecast\n",
       "\n",
       "**Tool Usage Feedback**: Fair tool appropriateness (50%): Some incorrect tools were used. Excellent tool completeness (100%): Agent used almost all necessary tools. Correctly used: get_electricity_prices. Extra tools used: get_weather_forecast.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: solar_maximization_cloudy\n",
       "**Question**: It's going to be cloudy tomorrow. How can I maximize my solar panel output?\n",
       "\n",
       "**Response Score**: 0.50 | **Tool Usage Score**: 0.50\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 7/14). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: query_solar_generation, get_weather_forecast | **Expected Tools**: get_weather_forecast, search_energy_tips | **Correct Tools**: get_weather_forecast | **Missed Tools**: search_energy_tips | **Extra Tools**: query_solar_generation\n",
       "\n",
       "**Tool Usage Feedback**: Fair tool appropriateness (50%): Some incorrect tools were used. Fair tool completeness (50%): Some necessary tools were missed. Correctly used: get_weather_forecast. Missed tools: search_energy_tips. Extra tools used: query_solar_generation.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: solar_maximization_sunny\n",
       "**Question**: It will be sunny all week. How can I make the most of my solar panels?\n",
       "\n",
       "**Response Score**: 0.57 | **Tool Usage Score**: 0.67\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 7/11). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: get_weather_forecast | **Expected Tools**: get_weather_forecast, search_energy_tips | **Correct Tools**: get_weather_forecast | **Missed Tools**: search_energy_tips | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Excellent tool appropriateness (100%): Agent selected the right tools. Fair tool completeness (50%): Some necessary tools were missed. Correctly used: get_weather_forecast. Missed tools: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: general_energy_savings\n",
       "**Question**: What are some general tips for saving energy at home?\n",
       "\n",
       "**Response Score**: 0.46 | **Tool Usage Score**: 1.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 7/17). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: search_energy_tips | **Expected Tools**: search_energy_tips | **Correct Tools**: search_energy_tips | **Missed Tools**: [] | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Perfect tool selection! All expected tools were used and no unnecessary tools were called. Correctly used: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: device_best_practices\n",
       "**Question**: What are the best practices for using my refrigerator efficiently?\n",
       "\n",
       "**Response Score**: 0.43 | **Tool Usage Score**: 1.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 5/14). Response could be more actionable.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: search_energy_tips | **Expected Tools**: search_energy_tips | **Correct Tools**: search_energy_tips | **Missed Tools**: [] | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Perfect tool selection! All expected tools were used and no unnecessary tools were called. Correctly used: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n",
       "### Test Case: seasonal_energy_management\n",
       "**Question**: How should my energy habits change from winter to summer?\n",
       "\n",
       "**Response Score**: 0.80 | **Tool Usage Score**: 0.00\n",
       "\n",
       "**Feedback**: Response is relevant to the question. Response is missing many expected keywords (found 13/22). Response provides actionable advice.\n",
       "\n",
       "**Details**\n",
       "\n",
       "**Used Tools**: [] | **Expected Tools**: search_energy_tips | **Correct Tools**: [] | **Missed Tools**: search_energy_tips | **Extra Tools**: []\n",
       "\n",
       "**Tool Usage Feedback**: Poor tool appropriateness (0%): Many incorrect or unnecessary tools were used. Poor tool completeness (0%): Many necessary tools were not used. Missed tools: search_energy_tips.\n",
       "\n",
       "---\n",
       "\n"
      ],
      "text/plain": [
       "<IPython.core.display.Markdown object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from IPython.display import display, Markdown\n",
    "\n",
    "def display_evaluation_report(report):\n",
    "    \"\"\"Displays the evaluation report in Markdown format.\"\"\"\n",
    "    display(Markdown(report))\n",
    "\n",
    "report = generate_evaluation_report(test_results)\n",
    "display_evaluation_report(report)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
</file_content>

<file_content path="master_project/README.md">
# EcoHome Energy Advisor

An AI-powered energy optimization agent that helps customers reduce electricity costs and environmental impact through personalized recommendations.

## Project Overview

EcoHome is a smart-home energy start-up that helps customers with solar panels, electric vehicles, and smart thermostats optimize their energy usage. The Energy Advisor agent provides personalized recommendations about when to run devices to minimize costs and carbon footprint.

### Key Features

- **Weather Integration**: Uses weather forecasts to predict solar generation
- **Dynamic Pricing**: Considers time-of-day electricity prices for cost optimization
- **Historical Analysis**: Queries past energy usage patterns for personalized advice
- **RAG Pipeline**: Retrieves relevant energy-saving tips and best practices
- **Multi-device Optimization**: Handles EVs, HVAC, appliances, and solar systems
- **Cost Calculations**: Provides specific savings estimates and ROI analysis

## Project Structure

```
ecohome_starter/
âââ models/
â   âââ __init__.py
â   âââ energy.py              # Database models for energy data
âââ data/
â   âââ documents/
â       âââ tip_device_best_practices.txt
â       âââ tip_energy_savings.txt
âââ agent.py                   # Main Energy Advisor agent
âââ tools.py                   # Agent tools (weather, pricing, database, RAG)
âââ requirements.txt           # Python dependencies
âââ 01_db_setup.ipynb         # Database setup and sample data
âââ 02_rag_setup.ipynb        # RAG pipeline setup
âââ 03_agent_evaluation.ipynb # Agent testing and evaluation
âââ 04_agent_run.ipynb        # Running the agent with examples
âââ README.md                  # This file
```

## Setup Instructions

### 1. Install Dependencies

```bash
pip install -r requirements.txt
```

### 2. Set Environment Variables

### Python Version

This project was developed and tested with Python 3.10.18.

Create a `.env` file with your API keys:

```bash
VOCAREUM_API_KEY=your_vocareum_api_key_here
OPENAI_API_KEY=your_openai_api_key_here
```

### 3. Run the Notebooks

Execute the notebooks in order:

1. **01_db_setup.ipynb** - Set up the database and populate with sample data
2. **02_rag_setup.ipynb** - Configure the RAG pipeline for energy tips
3. **03_run_and_evaluate.ipynb** - Test and evaluate the agent with comprehensive test cases

## Agent Capabilities

### Tools Available

- **Weather Forecast**: Get hourly weather predictions and solar irradiance
- **Electricity Pricing**: Access time-of-day pricing data
- **Energy Usage Query**: Retrieve historical consumption data
- **Solar Generation Query**: Get past solar production data
- **Energy Tips Search**: Find relevant energy-saving recommendations
- **Savings Calculator**: Compute potential cost savings

### Example Questions

The Energy Advisor can answer questions like:

- "When should I charge my electric car tomorrow to minimize cost and maximize solar power?"
- "What temperature should I set my thermostat on Wednesday afternoon if electricity prices spike?"
- "Suggest three ways I can reduce energy use based on my usage history."
- "How much can I save by running my dishwasher during off-peak hours?"

## Database Schema

### Energy Usage Table
- `timestamp`: When the energy was consumed
- `consumption_kwh`: Amount of energy used
- `device_type`: Type of device (EV, HVAC, appliance)
- `device_name`: Specific device name
- `cost_usd`: Cost at time of usage

### Solar Generation Table
- `timestamp`: When the energy was generated
- `generation_kwh`: Amount of solar energy produced
- `weather_condition`: Weather during generation
- `temperature_c`: Temperature at time of generation
- `solar_irradiance`: Solar irradiance level

## Learning Objectives

This project helps students learn:

1. **Database Design**: Creating schemas for energy management systems
2. **API Integration**: Working with external weather and pricing APIs
3. **RAG Implementation**: Building retrieval-augmented generation pipelines
4. **Agent Development**: Creating intelligent agents with tool usage
5. **Evaluation Methods**: Testing and measuring agent performance
6. **Energy Optimization**: Understanding smart home energy management

## Key Technologies

- **LangChain**: Agent framework and tool integration
- **LangGraph**: Agent orchestration and workflow
- **ChromaDB**: Vector database for document retrieval
- **SQLAlchemy**: Database ORM and management
- **OpenAI**: LLM and embeddings
- **SQLite**: Local database storage

## Evaluation Criteria

The agent is evaluated on:

- **Accuracy**: Correct information and calculations
- **Relevance**: Responses address the user's question
- **Completeness**: Comprehensive answers with actionable advice
- **Tool Usage**: Appropriate use of available tools
- **Reasoning**: Clear explanation of recommendations

## Getting Started

1. Clone this repository
2. Install the required dependencies
3. Set up your environment variables
4. Run the notebooks in sequence
5. Test the agent with your own questions

## Contributing

This is a learning project. Feel free to:
- Add new tools and capabilities
- Improve the evaluation metrics
- Enhance the RAG pipeline
- Add more sophisticated optimization algorithms

## License

This project is for educational purposes as part of the Udacity Course 2 curriculum.
</file_content>

<file_content path="master_project/agent.py">
import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage
from langgraph.prebuilt import create_react_agent
from tools import TOOL_KIT

load_dotenv()


class Agent:
    def __init__(self, instructions:str, model:str="gpt-4o-mini"):

        # Initialize the LLM
        llm = ChatOpenAI(
            model=model,
            temperature=0.0,
            base_url="https://openai.vocareum.com/v1",
            api_key=os.getenv("VOCAREUM_API_KEY")
        )

        # Create the Energy Advisor agent
        self.graph = create_react_agent(
            name="energy_advisor",
            prompt=SystemMessage(content=instructions),
            model=llm,
            tools=TOOL_KIT,
        )

    def invoke(self, question: str, context:str=None) -> str:
        """
        Ask the Energy Advisor a question about energy optimization.
        
        Args:
            question (str): The user's question about energy optimization
            location (str): Location for weather and pricing data
        
        Returns:
            str: The advisor's response with recommendations
        """
        
        messages = []
        if context:
            # Add some context to the question as a system message
            messages.append(
                ("system", context)
            )

        messages.append(
            ("user", question)
        )
        
        # Get response from the agent
        response = self.graph.invoke(
            input= {
                "messages": messages
            }
        )
        
        return response

    def get_agent_tools(self):
        """Get list of available tools for the Energy Advisor"""
        return [t.name for t in TOOL_KIT]
</file_content>

<file_content path="master_project/requirements.txt">
# Core LangChain dependencies
langchain>=0.3.25
langchain-core==0.3.76
langchain-openai==0.3.6
langchain-community==0.3.24
langchain-chroma==0.2.6
langgraph==0.2.76

# Database dependencies
sqlalchemy==2.0.23

# Vector store and embeddings
chromadb==1.1.1
openai>=1.58.1

pydantic==2.12.1
# Data processing
pandas==2.1.4
numpy==1.26.4

# Environment and configuration
python-dotenv==1.0.0

# Jupyter notebook dependencies
jupyter==1.0.0
ipykernel==6.25.2

# Evaluation and testing
pytest==7.4.3
pytest-asyncio==0.21.1

# Additional utilities
requests==2.31.0
python-dateutil==2.8.2
</file_content>

<file_content path="master_project/temp_db_setup.py">
# Import the necessary libraries
from datetime import datetime, timedelta
import random

from models.energy import DatabaseManager

# Create a DatabaseManager instance
# Initialize it with the path "data/energy_data.db"
db_manager = DatabaseManager("data/energy_data.db")

# Create the database tables
# Use the create_tables() method from your DatabaseManager
db_manager.create_tables()

# Generate sample energy usage data for the past 30 days
# Include different device types: EV, HVAC, appliances
# Use realistic consumption patterns (higher during peak hours)

# Device types and their typical consumption patterns
device_types = {
    'EV': {'base_kwh': 10, 'variation': 5, 'peak_hours': [18, 19, 20, 21]},
    'HVAC': {'base_kwh': 2, 'variation': 1, 'peak_hours': [12, 13, 14, 15, 16, 17]},
    'appliance': {'base_kwh': 1.5, 'variation': 0.5, 'peak_hours': [19, 20, 21, 22]}
}

# Generate data for the past 30 days
start_date = datetime.now() - timedelta(days=30)
records_created = 0

for day in range(30):
    current_date = start_date + timedelta(days=day)
    
    for hour in range(24):
        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)
        
        # Generate usage for each device type
        for device_type, config in device_types.items():
            # Base consumption with variation
            base_consumption = config['base_kwh']
            variation = random.uniform(-config['variation'], config['variation'])
            
            # Peak hour multiplier
            peak_multiplier = 1.5 if hour in config['peak_hours'] else 0.8
            
            consumption = max(0, (base_consumption + variation) * peak_multiplier)
            
            # Calculate cost (simplified pricing)
            price_per_kwh = 0.15 if hour in config['peak_hours'] else 0.10
            cost = consumption * price_per_kwh
            
            # Device names
            device_names = {
                'EV': 'Tesla Model 3',
                'HVAC': 'Main AC Unit',
                'appliance': random.choice(['Dishwasher', 'Washing Machine', 'Dryer'])
            }
            
            # Add record to database
            db_manager.add_usage_record(
                timestamp=timestamp,
                consumption_kwh=consumption,
                device_type=device_type,
                device_name=device_names[device_type],
                cost_usd=cost
            )
            records_created += 1

print(f"Created {records_created} energy usage records")

# Generate sample solar generation data
# Consider weather patterns, time of day, and seasonal variations

# Weather conditions and their impact on solar generation
weather_conditions = {
    'sunny': {'multiplier': 1.0, 'probability': 0.4},
    'partly_cloudy': {'multiplier': 0.6, 'probability': 0.3},
    'cloudy': {'multiplier': 0.3, 'probability': 0.2},
    'rainy': {'multiplier': 0.1, 'probability': 0.1}
}

# Generate solar generation data for the same period
start_date = datetime.now() - timedelta(days=30)
generation_records = 0

for day in range(30):
    current_date = start_date + timedelta(days=day)
    
    # Select weather condition for the day
    weather_choice = random.choices(
        list(weather_conditions.keys()),
        weights=[weather_conditions[w]['probability'] for w in weather_conditions.keys()]
    )[0]
    weather_multiplier = weather_conditions[weather_choice]['multiplier']
    
    for hour in range(24):
        timestamp = current_date.replace(hour=hour, minute=0, second=0, microsecond=0)
        
        # Solar generation only during daylight hours (6 AM to 6 PM)
        if 6 <= hour <= 18:
            # Base generation curve (peak at noon)
            hour_factor = 1 - abs(hour - 12) / 6  # Peak at hour 12
            base_generation = 5.0 * hour_factor  # Max 5 kWh at peak
            
            # Apply weather multiplier
            generation = base_generation * weather_multiplier
            
            # Add some random variation
            generation *= random.uniform(0.8, 1.2)
            generation = max(0, generation)
            
            # Calculate temperature (affects solar efficiency)
            base_temp = 20 + random.uniform(-5, 5)
            temp_factor = 1.0 if 15 <= base_temp <= 35 else 0.9
            
            # Solar irradiance calculation
            irradiance = 800 * hour_factor * weather_multiplier if generation > 0 else 0
            
            # Add record to database
            db_manager.add_generation_record(
                timestamp=timestamp,
                generation_kwh=generation,
                weather_condition=weather_choice,
                temperature_c=base_temp * temp_factor,
                solar_irradiance=irradiance
            )
            generation_records += 1

print(f"Created {generation_records} solar generation records")

# Query the data to verify it was inserted correctly
# Show total consumption by device type
# Show daily solar generation patterns
# Calculate some basic statistics

# Get recent data for analysis
recent_usage = db_manager.get_recent_usage(24)  # Last 24 hours
recent_generation = db_manager.get_recent_generation(24)

print("=== Energy Usage Analysis ===")
print(f"Total records in last 24 hours: {len(recent_usage)}")

# Group by device type
device_consumption = {}
for record in recent_usage:
    device = record.device_type or 'unknown'
    if device not in device_consumption:
        device_consumption[device] = {'kwh': 0, 'cost': 0, 'records': 0}
    device_consumption[device]['kwh'] += record.consumption_kwh
    device_consumption[device]['cost'] += record.cost_usd or 0
    device_consumption[device]['records'] += 1

print("\nConsumption by device type:")
for device, data in device_consumption.items():
    print(f"  {device}: {data['kwh']:.2f} kWh, ${data['cost']:.2f}, {data['records']} records")

print(f"\n=== Solar Generation Analysis ===")
print(f"Total generation records in last 24 hours: {len(recent_generation)}")

total_generation = sum(r.generation_kwh for r in recent_generation)
print(f"Total generation: {total_generation:.2f} kWh")

# Weather breakdown
weather_breakdown = {}
for record in recent_generation:
    weather = record.weather_condition or 'unknown'
    if weather not in weather_breakdown:
        weather_breakdown[weather] = {'kwh': 0, 'records': 0}
    weather_breakdown[weather]['kwh'] += record.generation_kwh
    weather_breakdown[weather]['records'] += 1

print("\nGeneration by weather condition:")
for weather, data in weather_breakdown.items():
    print(f"  {weather}: {data['kwh']:.2f} kWh, {data['records']} records")

# Test the database query functions from tools.py
# Import and test: query_energy_usage, query_solar_generation, get_recent_energy_summary

from tools import query_energy_usage, query_solar_generation, get_recent_energy_summary

# Test querying data for the last 7 days
end_date = datetime.now().strftime("%Y-%m-%d")
start_date = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d")

print("=== Testing Database Tools ===")
print(f"Querying data from {start_date} to {end_date}")

# Test energy usage query
usage_data = query_energy_usage.invoke(
    input={
        "start_date": start_date, 
        "end_date": end_date,
    }
)
print(f"\nEnergy Usage Query Results:")
print(f"  Total records: {usage_data['total_records']}")
print(f"  Total consumption: {usage_data['total_consumption_kwh']} kWh")
print(f"  Total cost: ${usage_data['total_cost_usd']}")

# Test solar generation query
generation_data = query_solar_generation.invoke(
    input={
        "start_date": start_date, 
        "end_date": end_date,
    }
)
print(f"\nSolar Generation Query Results:")
print(f"  Total records: {generation_data['total_records']}")
print(f"  Total generation: {generation_data['total_generation_kwh']} kWh")
print(f"  Average daily: {generation_data['average_daily_generation']} kWh")

# Test recent energy summary
summary = get_recent_energy_summary.invoke(
    input={
        "hours": 24
    }
)
print(f"\nRecent Energy Summary:")
print(f"  Usage: {summary['usage']['total_consumption_kwh']} kWh, ${summary['usage']['total_cost_usd']}")
print(f"  Generation: {summary['generation']['total_generation_kwh']} kWh")
print(f"  Weather: {summary['generation']['average_weather']}")
</file_content>

<file_content path="master_project/tools.py">
"""
Tools for EcoHome Energy Advisor Agent
"""
import os
import json
import random
from datetime import datetime, timedelta
from typing import Dict, Any
from langchain_core.tools import tool
from langchain_chroma import Chroma
from langchain_openai import OpenAIEmbeddings
from langchain_community.document_loaders import TextLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from models.energy import DatabaseManager

# Initialize database manager
db_manager = DatabaseManager()

@tool
def get_weather_forecast(location: str, days: int = 3) -> Dict[str, Any]:
    """
    Get weather forecast for a specific location and number of days.

    Args:
        location (str): Location to get weather for (e.g., "San Francisco, CA")
        days (int): Number of days to forecast (1-7)

    Returns:
        Dict[str, Any]: Weather forecast data including temperature, conditions, and solar irradiance
        E.g:
        forecast = {
            "location": ...,
            "forecast_days": ...,
            "current": {
                "temperature_c": ...,
                "condition": random.choice(["sunny", "partly_cloudy", "cloudy"]),
                "humidity": ...,
                "wind_speed": ...
            },
            "hourly": [
                {
                    "hour": ..., # for hour in range(24)
                    "temperature_c": ...,
                    "condition": ...,
                    "solar_irradiance": ...,
                    "humidity": ...,
                    "wind_speed": ...
                },
            ]
        }
    """
    # Mock weather API - in production, use OpenWeatherMap or similar
    try:
        days = min(max(days, 1), 7)  # Limit to 1-7 days

        # Generate current weather
        current_condition = random.choice(["sunny", "partly_cloudy", "cloudy", "rainy"])
        current_temp = random.uniform(15, 30)

        forecast = {
            "location": location,
            "forecast_days": days,
            "generated_at": datetime.now().isoformat(),
            "current": {
                "temperature_c": round(current_temp, 1),
                "condition": current_condition,
                "humidity": random.randint(40, 80),
                "wind_speed": round(random.uniform(5, 20), 1)
            },
            "daily": []
        }

        # Generate forecast for each day
        for day in range(days):
            date = datetime.now() + timedelta(days=day)

            # Weather patterns with some continuity
            if day == 0:
                condition = current_condition
            else:
                # 60% chance to keep same weather, 40% to change
                if random.random() < 0.6:
                    condition = forecast["daily"][day-1]["condition"]
                else:
                    condition = random.choice(["sunny", "partly_cloudy", "cloudy", "rainy"])

            # Generate hourly forecast
            hourly_data = []
            for hour in range(24):
                # Temperature variation throughout day
                base_temp = 15 + 10 * (1 - abs(hour - 13) / 13)  # Peak at 1 PM
                temp_variation = random.uniform(-2, 2)
                temp = base_temp + temp_variation

                # Solar irradiance based on time of day and weather
                if 6 <= hour <= 18:
                    hour_factor = 1 - abs(hour - 12) / 6
                    weather_multipliers = {
                        "sunny": 1.0,
                        "partly_cloudy": 0.6,
                        "cloudy": 0.3,
                        "rainy": 0.1
                    }
                    solar_irradiance = 800 * hour_factor * weather_multipliers[condition]
                else:
                    solar_irradiance = 0

                hourly_data.append({
                    "hour": hour,
                    "temperature_c": round(temp, 1),
                    "condition": condition,
                    "solar_irradiance": round(solar_irradiance, 1),
                    "humidity": random.randint(40, 80),
                    "wind_speed": round(random.uniform(5, 20), 1)
                })

            forecast["daily"].append({
                "date": date.strftime("%Y-%m-%d"),
                "condition": condition,
                "temp_high_c": round(max(h["temperature_c"] for h in hourly_data), 1),
                "temp_low_c": round(min(h["temperature_c"] for h in hourly_data), 1),
                "hourly": hourly_data
            })

        return forecast
    except Exception as e:
        return {"error": f"Failed to get weather forecast: {str(e)}"} 

@tool
def get_electricity_prices(date: str = None) -> Dict[str, Any]:
    """
    Get electricity prices for a specific date or current day.

    Args:
        date (str): Date in YYYY-MM-DD format (defaults to today)

    Returns:
        Dict[str, Any]: Electricity pricing data with hourly rates
        E.g:
        prices = {
            "date": ...,
            "pricing_type": "time_of_use",
            "currency": "USD",
            "unit": "per_kWh",
            "hourly_rates": [
                {
                    "hour": .., # for hour in range(24)
                    "rate": ..,
                    "period": ..,
                    "demand_charge": ...
                }
            ]
        }
    """
    try:
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")

        # Mock electricity pricing - in real implementation, this would call a pricing API
        # Base prices per kWh
        base_price = 0.10
        mid_peak_price = 0.15
        peak_price = 0.25

        # Demand charges (additional cost during peak times)
        peak_demand_charge = 0.05

        hourly_rates = []
        for hour in range(24):
            # Determine period and rate based on time of day
            # Off-peak: midnight-6am, 10pm-midnight
            # Mid-peak: 6am-4pm (excluding 12pm-6pm), 8pm-10pm
            # Peak: 4pm-8pm (typically highest demand)

            if 0 <= hour < 6 or hour >= 22:
                period = "off_peak"
                rate = base_price
                demand_charge = 0
            elif (6 <= hour < 16) or (20 <= hour < 22):
                period = "mid_peak"
                rate = mid_peak_price
                demand_charge = 0
            else:  # 16-20 (4pm-8pm)
                period = "peak"
                rate = peak_price
                demand_charge = peak_demand_charge

            hourly_rates.append({
                "hour": hour,
                "rate": round(rate, 3),
                "period": period,
                "demand_charge": round(demand_charge, 3),
                "total_rate": round(rate + demand_charge, 3)
            })

        prices = {
            "date": date,
            "pricing_type": "time_of_use",
            "currency": "USD",
            "unit": "per_kWh",
            "hourly_rates": hourly_rates,
            "summary": {
                "off_peak_rate": base_price,
                "mid_peak_rate": mid_peak_price,
                "peak_rate": peak_price + peak_demand_charge,
                "peak_hours": "16:00-20:00",
                "off_peak_hours": "00:00-06:00, 22:00-24:00"
            }
        }

        return prices
    except Exception as e:
        return {"error": f"Failed to get electricity prices: {str(e)}"} 

@tool
def query_energy_usage(start_date: str, end_date: str, device_type: str = None) -> Dict[str, Any]:
    """
    Query energy usage data from the database for a specific date range.
    
    Args:
        start_date (str): Start date in YYYY-MM-DD format
        end_date (str): End date in YYYY-MM-DD format
        device_type (str): Optional device type filter (e.g., "EV", "HVAC", "appliance")
    
    Returns:
        Dict[str, Any]: Energy usage data with consumption details
    """
    try:
        start_dt = datetime.strptime(start_date, "%Y-%m-%d")
        end_dt = datetime.strptime(end_date, "%Y-%m-%d") + timedelta(days=1)
        
        records = db_manager.get_usage_by_date_range(start_dt, end_dt)
        
        if device_type:
            records = [r for r in records if r.device_type == device_type]
        
        usage_data = {
            "start_date": start_date,
            "end_date": end_date,
            "device_type": device_type,
            "total_records": len(records),
            "total_consumption_kwh": round(sum(r.consumption_kwh for r in records), 2),
            "total_cost_usd": round(sum(r.cost_usd or 0 for r in records), 2),
            "records": []
        }
        
        for record in records:
            usage_data["records"].append({
                "timestamp": record.timestamp.isoformat(),
                "consumption_kwh": record.consumption_kwh,
                "device_type": record.device_type,
                "device_name": record.device_name,
                "cost_usd": record.cost_usd
            })
        
        return usage_data
    except Exception as e:
        return {"error": f"Failed to query energy usage: {str(e)}"}

@tool
def query_solar_generation(start_date: str, end_date: str) -> Dict[str, Any]:
    """
    Query solar generation data from the database for a specific date range.
    
    Args:
        start_date (str): Start date in YYYY-MM-DD format
        end_date (str): End date in YYYY-MM-DD format
    
    Returns:
        Dict[str, Any]: Solar generation data with production details
    """
    try:
        start_dt = datetime.strptime(start_date, "%Y-%m-%d")
        end_dt = datetime.strptime(end_date, "%Y-%m-%d") + timedelta(days=1)
        
        records = db_manager.get_generation_by_date_range(start_dt, end_dt)
        
        generation_data = {
            "start_date": start_date,
            "end_date": end_date,
            "total_records": len(records),
            "total_generation_kwh": round(sum(r.generation_kwh for r in records), 2),
            "average_daily_generation": round(sum(r.generation_kwh for r in records) / max(1, (end_dt - start_dt).days), 2),
            "records": []
        }
        
        for record in records:
            generation_data["records"].append({
                "timestamp": record.timestamp.isoformat(),
                "generation_kwh": record.generation_kwh,
                "weather_condition": record.weather_condition,
                "temperature_c": record.temperature_c,
                "solar_irradiance": record.solar_irradiance
            })
        
        return generation_data
    except Exception as e:
        return {"error": f"Failed to query solar generation: {str(e)}"}

@tool
def get_recent_energy_summary(hours: int = 24) -> Dict[str, Any]:
    """
    Get a summary of recent energy usage and solar generation.
    
    Args:
        hours (int): Number of hours to look back (default 24)
    
    Returns:
        Dict[str, Any]: Summary of recent energy data
    """
    try:
        usage_records = db_manager.get_recent_usage(hours)
        generation_records = db_manager.get_recent_generation(hours)
        
        summary = {
            "time_period_hours": hours,
            "usage": {
                "total_consumption_kwh": round(sum(r.consumption_kwh for r in usage_records), 2),
                "total_cost_usd": round(sum(r.cost_usd or 0 for r in usage_records), 2),
                "device_breakdown": {}
            },
            "generation": {
                "total_generation_kwh": round(sum(r.generation_kwh for r in generation_records), 2),
                "average_weather": "sunny" if generation_records else "unknown"
            }
        }
        
        # Calculate device breakdown
        for record in usage_records:
            device = record.device_type or "unknown"
            if device not in summary["usage"]["device_breakdown"]:
                summary["usage"]["device_breakdown"][device] = {
                    "consumption_kwh": 0,
                    "cost_usd": 0,
                    "records": 0
                }
            summary["usage"]["device_breakdown"][device]["consumption_kwh"] += record.consumption_kwh
            summary["usage"]["device_breakdown"][device]["cost_usd"] += record.cost_usd or 0
            summary["usage"]["device_breakdown"][device]["records"] += 1
        
        # Round the breakdown values
        for device_data in summary["usage"]["device_breakdown"].values():
            device_data["consumption_kwh"] = round(device_data["consumption_kwh"], 2)
            device_data["cost_usd"] = round(device_data["cost_usd"], 2)
        
        return summary
    except Exception as e:
        return {"error": f"Failed to get recent energy summary: {str(e)}"}

@tool
def search_energy_tips(query: str, max_results: int = 5) -> Dict[str, Any]:
    """
    Search for energy-saving tips and best practices using RAG.
    
    Args:
        query (str): Search query for energy tips
        max_results (int): Maximum number of results to return
    
    Returns:
        Dict[str, Any]: Relevant energy tips and best practices
    """
    try:
        # Initialize vector store if it doesn't exist
        persist_directory = "data/vectorstore"
        if not os.path.exists(persist_directory):
            os.makedirs(persist_directory)
        
        # Load documents if vector store doesn't exist
        if not os.path.exists(os.path.join(persist_directory, "chroma.sqlite3")):
            # Load documents
            documents = []
            for doc_path in ["data/documents/tip_device_best_practices.txt", "data/documents/tip_energy_savings.txt"]:
                if os.path.exists(doc_path):
                    loader = TextLoader(doc_path)
                    docs = loader.load()
                    documents.extend(docs)
            
            # Split documents
            text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
            splits = text_splitter.split_documents(documents)
            
            # Create vector store
            embeddings = OpenAIEmbeddings()
            vectorstore = Chroma.from_documents(
                documents=splits,
                embedding=embeddings,
                persist_directory=persist_directory
            )
        else:
            # Load existing vector store
            embeddings = OpenAIEmbeddings()
            vectorstore = Chroma(
                persist_directory=persist_directory,
                embedding_function=embeddings
            )
        
        # Search for relevant documents
        docs = vectorstore.similarity_search(query, k=max_results)
        
        results = {
            "query": query,
            "total_results": len(docs),
            "tips": []
        }
        
        for i, doc in enumerate(docs):
            results["tips"].append({
                "rank": i + 1,
                "content": doc.page_content,
                "source": doc.metadata.get("source", "unknown"),
                "relevance_score": "high" if i < 2 else "medium" if i < 4 else "low"
            })
        
        return results
    except Exception as e:
        return {"error": f"Failed to search energy tips: {str(e)}"}

@tool
def calculate_energy_savings(device_type: str, current_usage_kwh: float, 
                           optimized_usage_kwh: float, price_per_kwh: float = 0.12) -> Dict[str, Any]:
    """
    Calculate potential energy savings from optimization.
    
    Args:
        device_type (str): Type of device being optimized
        current_usage_kwh (float): Current energy usage in kWh
        optimized_usage_kwh (float): Optimized energy usage in kWh
        price_per_kwh (float): Price per kWh (default 0.12)
    
    Returns:
        Dict[str, Any]: Savings calculation results
    """
    savings_kwh = current_usage_kwh - optimized_usage_kwh
    savings_usd = savings_kwh * price_per_kwh
    savings_percentage = (savings_kwh / current_usage_kwh) * 100 if current_usage_kwh > 0 else 0
    
    return {
        "device_type": device_type,
        "current_usage_kwh": current_usage_kwh,
        "optimized_usage_kwh": optimized_usage_kwh,
        "savings_kwh": round(savings_kwh, 2),
        "savings_usd": round(savings_usd, 2),
        "savings_percentage": round(savings_percentage, 1),
        "price_per_kwh": price_per_kwh,
        "annual_savings_usd": round(savings_usd * 365, 2)
    }


TOOL_KIT = [
    get_weather_forecast,
    get_electricity_prices,
    query_energy_usage,
    query_solar_generation,
    get_recent_energy_summary,
    search_energy_tips,
    calculate_energy_savings
]
</file_content>

<file_content path="master_project/models/__init__.py">
# EcoHome Models
</file_content>

<file_content path="master_project/models/energy.py">
"""
Energy data models for EcoHome Energy Advisor
"""
from datetime import datetime
from typing import Optional
from sqlalchemy import Column, Integer, Float, DateTime, String, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

Base = declarative_base()

class EnergyUsage(Base):
    """Model for energy consumption data"""
    __tablename__ = "energy_usage"
    
    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    consumption_kwh = Column(Float, nullable=False)
    device_type = Column(String(50), nullable=True)  # e.g., "EV", "HVAC", "appliance"
    device_name = Column(String(100), nullable=True)  # e.g., "Tesla Model 3", "Main AC"
    cost_usd = Column(Float, nullable=True)  # Cost at time of usage
    
    def __repr__(self):
        return f"<EnergyUsage(timestamp={self.timestamp}, consumption={self.consumption_kwh}kWh, device={self.device_name})>"

class SolarGeneration(Base):
    """Model for solar generation data"""
    __tablename__ = "solar_generation"
    
    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    generation_kwh = Column(Float, nullable=False)
    weather_condition = Column(String(50), nullable=True)  # e.g., "sunny", "cloudy", "rainy"
    temperature_c = Column(Float, nullable=True)
    solar_irradiance = Column(Float, nullable=True)  # W/mÂ²
    
    def __repr__(self):
        return f"<SolarGeneration(timestamp={self.timestamp}, generation={self.generation_kwh}kWh, weather={self.weather_condition})>"

class DatabaseManager:
    """Database manager for EcoHome energy data"""
    
    def __init__(self, db_path: str = "data/energy_data.db"):
        self.db_path = db_path
        self.engine = create_engine(f"sqlite:///{db_path}")
        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
        
    def create_tables(self):
        """Create all tables"""
        Base.metadata.create_all(bind=self.engine)
        print(f"Database tables created at {self.db_path}")
    
    def get_session(self):
        """Get database session"""
        return self.SessionLocal()
    
    def add_usage_record(self, timestamp: datetime, consumption_kwh: float, 
                        device_type: str = None, device_name: str = None, cost_usd: float = None):
        """Add energy usage record"""
        session = self.get_session()
        try:
            record = EnergyUsage(
                timestamp=timestamp,
                consumption_kwh=consumption_kwh,
                device_type=device_type,
                device_name=device_name,
                cost_usd=cost_usd
            )
            session.add(record)
            session.commit()
            return record
        finally:
            session.close()
    
    def add_generation_record(self, timestamp: datetime, generation_kwh: float,
                            weather_condition: str = None, temperature_c: float = None,
                            solar_irradiance: float = None):
        """Add solar generation record"""
        session = self.get_session()
        try:
            record = SolarGeneration(
                timestamp=timestamp,
                generation_kwh=generation_kwh,
                weather_condition=weather_condition,
                temperature_c=temperature_c,
                solar_irradiance=solar_irradiance
            )
            session.add(record)
            session.commit()
            return record
        finally:
            session.close()
    
    def get_usage_by_date_range(self, start_date: datetime, end_date: datetime):
        """Get energy usage records within date range"""
        session = self.get_session()
        try:
            return session.query(EnergyUsage).filter(
                EnergyUsage.timestamp >= start_date,
                EnergyUsage.timestamp <= end_date
            ).order_by(EnergyUsage.timestamp).all()
        finally:
            session.close()
    
    def get_generation_by_date_range(self, start_date: datetime, end_date: datetime):
        """Get solar generation records within date range"""
        session = self.get_session()
        try:
            return session.query(SolarGeneration).filter(
                SolarGeneration.timestamp >= start_date,
                SolarGeneration.timestamp <= end_date
            ).order_by(SolarGeneration.timestamp).all()
        finally:
            session.close()
    
    def get_recent_usage(self, hours: int = 24):
        """Get recent usage records"""
        from datetime import datetime, timedelta
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)
        return self.get_usage_by_date_range(start_time, end_time)
    
    def get_recent_generation(self, hours: int = 24):
        """Get recent solar generation records"""
        from datetime import datetime, timedelta
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)
        return self.get_generation_by_date_range(start_time, end_time)
</file_content>

<file_content path="master_project/data/documents/tip_device_best_practices.txt">
Large devices like electric vehicles, washing machines and dishwashers often support delayed start or timer functions. Schedule these devices to run outside of peak electricity pricing hours or during periods of high solar generation. Consult your device manual for specific scheduling instructions.

Electric Vehicle Charging:
- Charge during off-peak hours (typically 11 PM to 6 AM) to save money
- Use Level 2 charging at home for faster charging when needed
- Set charging to complete just before you need the vehicle
- Consider charging during peak solar generation hours if you have solar panels

Washing Machine Optimization:
- Run full loads to maximize efficiency
- Use cold water for most loads to save energy
- Schedule loads during off-peak hours or when solar generation is high
- Clean the machine regularly to maintain efficiency

Dishwasher Best Practices:
- Only run when completely full
- Use the energy-saving or eco mode when available
- Schedule during off-peak hours or high solar generation periods
- Skip the heated dry cycle and air dry instead

Water Heater Management:
- Set temperature to 120Â°F for optimal efficiency
- Insulate hot water pipes to reduce heat loss
- Consider a timer to turn off during peak hours
- Drain sediment annually to maintain efficiency

HVAC System Optimization:
- Change air filters monthly for better airflow
- Clean outdoor condenser coils annually
- Use programmable thermostats to adjust temperatures automatically
- Seal ductwork to prevent air leaks

Pool and Spa Equipment:
- Run pool pumps during off-peak hours
- Use pool covers to reduce heating needs
- Consider variable-speed pumps for better efficiency
- Maintain proper chemical balance to reduce filtration needs
</file_content>

<file_content path="master_project/data/documents/tip_energy_savings.txt">
Saving energy at home can be simple and effective. Turn off lights when not in use and unplug devices that draw standby power. Use natural lighting during the day and replace incandescent bulbs with energy-efficient LEDs. Keep appliances clean and well-maintained to ensure they operate efficiently.

Smart thermostats can save up to 10% on heating and cooling costs by automatically adjusting temperatures when you're away. Set your thermostat to 68Â°F in winter and 78Â°F in summer for optimal energy savings.

Wash clothes in cold water and only run full loads. Use the dryer's moisture sensor instead of timed drying. Clean the lint filter after every load to improve efficiency.

Seal air leaks around windows and doors with weatherstripping or caulk. Add insulation to attics and walls to reduce heating and cooling needs.

Use power strips to easily turn off multiple devices at once. Many electronics continue to draw power even when turned off, known as phantom load.

Consider energy-efficient appliances when replacing old ones. Look for ENERGY STAR certified products that use 10-50% less energy than standard models.

Plant trees or install awnings to provide shade for your home during summer months. This can reduce cooling costs by up to 25%.

Use ceiling fans to circulate air and make rooms feel cooler, allowing you to raise the thermostat temperature by 4Â°F without discomfort.
</file_content>

<file_content path="master_project/data/documents/tip_energy_storage_optimization.txt">
Energy Storage Optimization

1.  Understanding Battery Storage:
    *   Types of batteries (e.g., Lithium-ion, Lead-acid) and their characteristics.
    *   Capacity (kWh) and Power (kW) ratings.
    *   Round-trip efficiency and depth of discharge.

2.  Time-of-Use (TOU) Arbitrage:
    *   Charge batteries during off-peak electricity hours (when prices are low).
    *   Discharge batteries during peak electricity hours (when prices are high) to reduce grid consumption.
    *   Automate this process with a Home Energy Management System (HEMS).

3.  Solar Self-Consumption Maximization:
    *   Store excess solar energy generated during the day.
    *   Use stored solar energy during the evening or night when solar production is zero.
    *   Reduces reliance on the grid and maximizes the value of solar panels.

4.  Backup Power:
    *   Use battery storage to provide backup power during grid outages.
    *   Ensure critical loads are connected to the battery system.

5.  Grid Services and Demand Response:
    *   Participate in utility demand response programs where you get compensated for reducing consumption or discharging batteries during grid stress events.
    *   Potentially provide grid services like frequency regulation (advanced).

6.  System Sizing and ROI:
    *   Properly size battery system based on energy consumption patterns, solar production, and desired backup duration.
    *   Calculate the Return on Investment (ROI) considering electricity bill savings, incentives, and potential grid service revenue.

7.  Maintenance and Longevity:
    *   Follow manufacturer guidelines for battery maintenance.
    *   Optimize charging/discharging cycles to extend battery lifespan.
</file_content>

<file_content path="master_project/data/documents/tip_hvac_optimization.txt">
# HVAC System Optimization Strategies

## Temperature Management

### Optimal Thermostat Settings
- Summer cooling: Set thermostat to 78Â°F (26Â°C) when home, 85Â°F (29Â°C) when away
- Winter heating: Set to 68Â°F (20Â°C) when home, 60Â°F (15Â°C) when away or sleeping
- Each degree of adjustment can save 3-5% on heating/cooling costs
- Use programmable or smart thermostats for automated scheduling

### Zone-Based Heating and Cooling
- Close vents in unused rooms to redirect airflow
- Install zone control systems for multi-level homes
- Use ceiling fans to improve air circulation and reduce HVAC load
- Ceiling fans should rotate counterclockwise in summer, clockwise in winter

## System Maintenance

### Regular Filter Changes
- Replace or clean HVAC filters every 1-3 months
- Dirty filters reduce efficiency by 5-15%
- Consider high-efficiency pleated filters for better air quality
- Mark calendar reminders for filter replacements

### Annual Professional Maintenance
- Schedule professional HVAC inspection annually
- Clean coils, check refrigerant levels, and test system efficiency
- Well-maintained systems use 15-20% less energy
- Address minor issues before they become costly repairs

### Duct Sealing and Insulation
- Seal air leaks in ductwork with mastic sealant or metal tape
- Insulate ducts in unconditioned spaces (attics, crawl spaces, garages)
- Leaky ducts can waste 20-30% of heating and cooling energy
- Consider professional duct testing and sealing

## Smart HVAC Strategies

### Time-of-Use Optimization
- Pre-cool or pre-heat home during off-peak electricity hours
- Use thermal mass of the building to maintain comfort during peak hours
- Reduce HVAC use during peak pricing periods (typically 4-8 PM)
- Program thermostat to adjust temperatures based on electricity rates

### Integration with Weather Forecasts
- Adjust thermostat settings based on upcoming weather
- Open windows for natural ventilation during mild weather
- Pre-cool before heat waves to reduce peak demand
- Use night setback more aggressively on mild nights

### Humidity Control
- Maintain 30-50% relative humidity for optimal comfort
- Lower humidity allows higher thermostat settings in summer
- Use dehumidifiers in humid climates to reduce cooling load
- Ensure proper drainage from HVAC condensate

## Advanced Efficiency Measures

### Heat Pump Optimization
- Heat pumps are 2-3x more efficient than traditional systems
- Use auxiliary heat only when necessary (below 35Â°F/2Â°C)
- Maintain outdoor units clear of debris and snow
- Consider dual-fuel systems for extreme climates

### Variable Speed Systems
- Variable speed compressors adjust output to match demand
- Run more efficiently at partial loads
- Provide better humidity control and air filtration
- Can reduce energy use by 20-40% compared to single-speed systems

### Thermal Envelope Improvements
- Seal air leaks around windows, doors, and penetrations
- Add insulation to attics, walls, and crawl spaces
- Install energy-efficient windows with low-E coatings
- Use weatherstripping and door sweeps to reduce drafts

## Seasonal Strategies

### Summer Cooling Tips
- Use window coverings to block direct sunlight
- Cook outdoors or use microwave to reduce indoor heat gain
- Run heat-generating appliances in the evening
- Plant shade trees on south and west sides of home
- Use exhaust fans when cooking or showering

### Winter Heating Tips
- Open curtains on south-facing windows during the day
- Close curtains at night to retain heat
- Use space heaters for spot heating in occupied rooms
- Reverse ceiling fan direction to push warm air down
- Keep outdoor units clear of snow and ice

### Shoulder Season Strategies
- Use natural ventilation instead of HVAC when possible
- Open windows in morning and evening for free cooling
- Use whole-house fans to purge hot air in the evening
- Take advantage of temperature swings to minimize HVAC use

## Cost-Benefit Analysis

### Energy Savings Potential
- Programmable thermostat: $180/year savings
- Regular maintenance: 15% reduction in HVAC costs
- Duct sealing: $200-400/year savings
- Heat pump upgrade: 30-50% reduction in heating costs
- Insulation improvements: 10-30% total energy savings

### Return on Investment
- Smart thermostat: 1-2 year payback
- Professional duct sealing: 3-5 year payback
- Heat pump installation: 7-12 year payback
- Insulation upgrades: 3-8 year payback
- Window replacements: 10-20 year payback
</file_content>

<file_content path="master_project/data/documents/tip_renewable_energy_integration.txt">
Renewable Energy Integration

1.  Solar Photovoltaic (PV) Systems:
    *   **Grid-Tied Systems:** Connected to the utility grid, allowing you to draw power when solar production is low and send excess power back to the grid (net metering).
    *   **Off-Grid Systems:** Independent of the utility grid, requiring battery storage to supply power during non-daylight hours.
    *   **Hybrid Systems:** Combine grid-tied functionality with battery storage for backup power and optimized self-consumption.
    *   **Optimization:** Orient panels for maximum sun exposure, keep them clean, and monitor performance.

2.  Battery Energy Storage Systems (BESS):
    *   **Purpose:** Store excess renewable energy for later use, provide backup power, and enable time-of-use arbitrage.
    *   **Integration with Solar:** Charge batteries with solar during the day, discharge at night or during peak demand.
    *   **Types:** Lithium-ion is most common for residential, but other chemistries exist.

3.  Wind Energy:
    *   **Small Wind Turbines:** Suitable for properties with consistent wind resources and sufficient space.
    *   **Integration:** Can be integrated with solar and battery storage for a more resilient hybrid system.

4.  Geothermal Energy:
    *   **Geothermal Heat Pumps:** Use the stable temperature of the earth to provide highly efficient heating and cooling.
    *   **Integration:** Can significantly reduce HVAC energy consumption, complementing other renewable sources.

5.  Hydroelectric (Micro-hydro):
    *   **Applicability:** Limited to properties with access to a flowing water source with sufficient head and flow.
    *   **Benefits:** Provides consistent, baseload renewable power.

6.  Smart Grid Integration:
    *   **Demand Response:** Participate in utility programs to reduce energy consumption during peak demand periods, often by leveraging smart devices and energy storage.
    *   **Virtual Power Plants (VPPs):** Aggregation of distributed energy resources (like solar and batteries) to provide grid services.

7.  Challenges and Considerations:
    *   **Intermittency:** Solar and wind power are variable; storage and grid integration are crucial.
    *   **Cost:** Initial investment can be high, but incentives and long-term savings can offset this.
    *   **Permitting and Regulations:** Local regulations can impact installation and grid connection.
    *   **Maintenance:** Regular maintenance is required for optimal performance and longevity.
</file_content>

<file_content path="master_project/data/documents/tip_seasonal_energy_management.txt">
Seasonal Energy Management Strategies

1.  Summer Cooling Optimization:
    *   Set thermostat higher when away (e.g., 78-80Â°F).
    *   Use ceiling fans to create a wind-chill effect, allowing higher thermostat settings.
    *   Close blinds and curtains during the day to block solar heat gain.
    *   Ensure HVAC system is regularly maintained (clean filters, professional tune-ups).
    *   Consider smart thermostats for automated scheduling and remote control.

2.  Winter Heating Optimization:
    *   Set thermostat lower when away or asleep (e.g., 60-65Â°F).
    *   Seal drafts around windows and doors with weatherstripping and caulk.
    *   Open curtains on sunny days to allow passive solar heating, close them at night to retain heat.
    *   Ensure furnace is regularly maintained (clean filters, professional tune-ups).
    *   Use programmable thermostats to match heating to occupancy.

3.  Shoulder Seasons (Spring/Fall) Strategies:
    *   Utilize natural ventilation: open windows at night to cool the home, close them during the day.
    *   Minimize reliance on HVAC by dressing appropriately for the indoor temperature.
    *   Perform seasonal maintenance on both heating and cooling systems.

4.  Appliance Usage:
    *   Run dishwashers and washing machines during off-peak hours, especially in summer to avoid adding heat to the home.
    *   Use outdoor clotheslines when weather permits.

5.  Landscaping:
    *   Plant deciduous trees on the south and west sides of the house to provide summer shade and allow winter sun.
    *   Use evergreen shrubs as windbreaks in winter.
</file_content>

<file_content path="master_project/data/documents/tip_smart_home_automation.txt">
# Smart Home Automation for Energy Efficiency

## Smart Thermostats and Climate Control

### Advanced Features
- Learn your schedule and preferences automatically
- Geofencing: adjust temperature when you leave/return home
- Remote control via smartphone apps
- Integration with voice assistants (Alexa, Google, Siri)
- Energy usage reports and recommendations

### Popular Smart Thermostats
- Nest Learning Thermostat: Auto-learning, energy history, remote sensors
- Ecobee SmartThermostat: Room sensors, voice control, occupancy detection
- Honeywell Home T9: Smart room sensors, geofencing, scheduling
- Typical savings: 10-23% on heating, 15% on cooling costs

### Optimization Strategies
- Use occupancy sensors to adjust temperature in real-time
- Integrate with weather forecasts for predictive adjustments
- Set different schedules for weekdays and weekends
- Enable eco-mode when away for extended periods
- Use room sensors to balance temperature across zones

## Smart Lighting Systems

### LED Smart Bulbs
- 75-80% more efficient than incandescent bulbs
- Last 15-25 times longer than traditional bulbs
- Dimmable and color-changing capabilities
- Schedulable on/off times and automation rules
- Motion sensors for automatic activation

### Smart Switches and Dimmers
- Control entire circuits without replacing bulbs
- Occupancy and vacancy sensors
- Dimming reduces energy use and extends bulb life
- Timer functions for automatic shutoff
- Integration with whole-home automation systems

### Lighting Automation Strategies
- Use motion sensors in bathrooms, closets, and hallways
- Schedule lights to turn off automatically when leaving
- Dim lights during evening hours to reduce consumption
- Use natural light sensors to adjust artificial lighting
- Create scenes for different activities with optimal lighting levels

## Smart Power Management

### Smart Plugs and Outlets
- Monitor energy usage of individual devices
- Schedule on/off times for appliances
- Remote control from smartphone
- Eliminate vampire power draw by cutting power completely
- Typical savings: $50-100/year per household

### Smart Power Strips
- Master-controlled outlets for entertainment centers
- Timer-based shutoff for device groups
- Individual outlet control and monitoring
- Surge protection combined with energy management
- USB charging ports with smart features

### Vampire Power Elimination
- Devices consume 5-10% of residential electricity when "off"
- Average home has 20-40 devices drawing standby power
- Smart plugs can eliminate this waste automatically
- Common culprits: TVs, cable boxes, game consoles, chargers
- Annual savings potential: $100-200 per household

## Smart Appliance Integration

### Connected Major Appliances
- Smart refrigerators: energy monitoring, temperature optimization
- Smart washers/dryers: delay start for off-peak hours
- Smart dishwashers: eco modes and cycle optimization
- Smart ovens: remote preheating, precise temperature control
- Energy Star certified smart appliances use 10-50% less energy

### Appliance Automation
- Run dishwasher and laundry during off-peak hours
- Receive notifications when cycles complete
- Monitor energy consumption in real-time
- Optimize settings based on load size and type
- Integration with home energy management systems

## Home Energy Management Systems (HEMS)

### Whole-Home Energy Monitoring
- Track electricity usage in real-time
- Identify energy hogs and inefficient devices
- Set energy budgets and receive alerts
- Historical data analysis and trend identification
- Integration with solar, battery, and EV chargers

### Popular HEMS Platforms
- Sense Home Energy Monitor: circuit-level detection, solar integration
- Emporia Vue: 16-circuit monitoring, solar and EV tracking
- Neurio Home Energy Monitor: real-time monitoring, smart home integration
- Typical savings: 5-15% through awareness and optimization

### Advanced HEMS Features
- Demand response program participation
- Automatic load shedding during peak pricing
- Battery storage optimization
- EV charging scheduling
- Integration with utility time-of-use rates

## Smart Window Treatments

### Automated Shades and Blinds
- Schedule opening/closing based on sun position
- Integration with temperature sensors
- Reduce solar heat gain in summer by 45-75%
- Reduce heat loss through windows by 10-25% in winter
- Voice and app control for convenience

### Smart Glass
- Electrochromic windows that tint automatically
- Reduce cooling costs by up to 20%
- Eliminate need for blinds and shades
- Maximize natural light while controlling heat
- Higher initial cost but excellent long-term ROI

## Voice Assistants and AI Integration

### Energy Management via Voice Control
- "Alexa, set thermostat to eco mode"
- "Hey Google, turn off all lights in 10 minutes"
- "Siri, what's my energy usage today?"
- Create custom routines for energy optimization
- Hands-free control improves compliance with energy plans

### AI-Powered Optimization
- Machine learning algorithms predict usage patterns
- Automatic adjustments based on occupancy and preferences
- Weather-based proactive climate control
- Anomaly detection for equipment failures
- Continuous optimization without user intervention

## Smart Water Heating

### Connected Water Heaters
- Remote temperature control and scheduling
- Vacation mode for extended periods away
- Leak detection and alerts
- Energy usage monitoring
- Heat pump water heaters with smart features

### Optimization Strategies
- Lower temperature to 120Â°F when possible
- Schedule heating during off-peak hours
- Use vacation mode when away
- Integrate with solar production data
- Monitor for efficiency degradation

## Home Automation Platforms

### Popular Ecosystems
- Apple HomeKit: Privacy-focused, secure, iOS-centric
- Google Home: AI-powered, voice control, wide compatibility
- Amazon Alexa: Extensive device support, skills marketplace
- Samsung SmartThings: Multi-protocol support, local processing
- Home Assistant: Open-source, highly customizable, local control

### Integration Best Practices
- Choose devices compatible with your preferred platform
- Use Z-Wave or Zigbee for reliable, low-power communication
- Implement local control where possible for reliability
- Create automation rules for maximum energy savings
- Regularly update firmware for security and features

## ROI and Implementation Strategy

### Cost-Benefit Analysis
- Smart thermostat: $200-300, 1-2 year payback
- Smart lighting: $10-50 per bulb, 2-3 year payback
- Smart plugs: $15-30 each, 1-2 year payback
- Energy monitor: $150-300, 2-4 year payback
- Whole-home automation: $1000-5000, 3-7 year payback

### Implementation Roadmap
1. Start with smart thermostat (highest impact)
2. Add smart lighting in high-use areas
3. Deploy smart plugs for major appliances
4. Install whole-home energy monitor
5. Expand to advanced automation and integration
6. Continuously refine rules based on data and habits
</file_content>

<file_content path="data/documents/tip_device_best_practices.txt">
Large devices like electric vehicles, washing machines and dishwashers often support delayed start or timer functions. Schedule these devices to run outside of peak electricity pricing hours or during periods of high solar generation. Consult your device manual for specific scheduling instructions.

Electric Vehicle Charging:
- Charge during off-peak hours (typically 11 PM to 6 AM) to save money
- Use Level 2 charging at home for faster charging when needed
- Set charging to complete just before you need the vehicle
- Consider charging during peak solar generation hours if you have solar panels

Washing Machine Optimization:
- Run full loads to maximize efficiency
- Use cold water for most loads to save energy
- Schedule loads during off-peak hours or when solar generation is high
- Clean the machine regularly to maintain efficiency

Dishwasher Best Practices:
- Only run when completely full
- Use the energy-saving or eco mode when available
- Schedule during off-peak hours or high solar generation periods
- Skip the heated dry cycle and air dry instead

Water Heater Management:
- Set temperature to 120Â°F for optimal efficiency
- Insulate hot water pipes to reduce heat loss
- Consider a timer to turn off during peak hours
- Drain sediment annually to maintain efficiency

HVAC System Optimization:
- Change air filters monthly for better airflow
- Clean outdoor condenser coils annually
- Use programmable thermostats to adjust temperatures automatically
- Seal ductwork to prevent air leaks

Pool and Spa Equipment:
- Run pool pumps during off-peak hours
- Use pool covers to reduce heating needs
- Consider variable-speed pumps for better efficiency
- Maintain proper chemical balance to reduce filtration needs
</file_content>

<file_content path="data/documents/tip_energy_savings.txt">
Saving energy at home can be simple and effective. Turn off lights when not in use and unplug devices that draw standby power. Use natural lighting during the day and replace incandescent bulbs with energy-efficient LEDs. Keep appliances clean and well-maintained to ensure they operate efficiently.

Smart thermostats can save up to 10% on heating and cooling costs by automatically adjusting temperatures when you're away. Set your thermostat to 68Â°F in winter and 78Â°F in summer for optimal energy savings.

Wash clothes in cold water and only run full loads. Use the dryer's moisture sensor instead of timed drying. Clean the lint filter after every load to improve efficiency.

Seal air leaks around windows and doors with weatherstripping or caulk. Add insulation to attics and walls to reduce heating and cooling needs.

Use power strips to easily turn off multiple devices at once. Many electronics continue to draw power even when turned off, known as phantom load.

Consider energy-efficient appliances when replacing old ones. Look for ENERGY STAR certified products that use 10-50% less energy than standard models.

Plant trees or install awnings to provide shade for your home during summer months. This can reduce cooling costs by up to 25%.

Use ceiling fans to circulate air and make rooms feel cooler, allowing you to raise the thermostat temperature by 4Â°F without discomfort.
</file_content>

<file_content path="data/documents/tip_energy_storage_optimization.txt">
Energy Storage Optimization

1.  Understanding Battery Storage:
    *   Types of batteries (e.g., Lithium-ion, Lead-acid) and their characteristics.
    *   Capacity (kWh) and Power (kW) ratings.
    *   Round-trip efficiency and depth of discharge.

2.  Time-of-Use (TOU) Arbitrage:
    *   Charge batteries during off-peak electricity hours (when prices are low).
    *   Discharge batteries during peak electricity hours (when prices are high) to reduce grid consumption.
    *   Automate this process with a Home Energy Management System (HEMS).

3.  Solar Self-Consumption Maximization:
    *   Store excess solar energy generated during the day.
    *   Use stored solar energy during the evening or night when solar production is zero.
    *   Reduces reliance on the grid and maximizes the value of solar panels.

4.  Backup Power:
    *   Use battery storage to provide backup power during grid outages.
    *   Ensure critical loads are connected to the battery system.

5.  Grid Services and Demand Response:
    *   Participate in utility demand response programs where you get compensated for reducing consumption or discharging batteries during grid stress events.
    *   Potentially provide grid services like frequency regulation (advanced).

6.  System Sizing and ROI:
    *   Properly size battery system based on energy consumption patterns, solar production, and desired backup duration.
    *   Calculate the Return on Investment (ROI) considering electricity bill savings, incentives, and potential grid service revenue.

7.  Maintenance and Longevity:
    *   Follow manufacturer guidelines for battery maintenance.
    *   Optimize charging/discharging cycles to extend battery lifespan.
</file_content>

<file_content path="data/documents/tip_hvac_optimization.txt">
# HVAC System Optimization Strategies

## Temperature Management

### Optimal Thermostat Settings
- Summer cooling: Set thermostat to 78Â°F (26Â°C) when home, 85Â°F (29Â°C) when away
- Winter heating: Set to 68Â°F (20Â°C) when home, 60Â°F (15Â°C) when away or sleeping
- Each degree of adjustment can save 3-5% on heating/cooling costs
- Use programmable or smart thermostats for automated scheduling

### Zone-Based Heating and Cooling
- Close vents in unused rooms to redirect airflow
- Install zone control systems for multi-level homes
- Use ceiling fans to improve air circulation and reduce HVAC load
- Ceiling fans should rotate counterclockwise in summer, clockwise in winter

## System Maintenance

### Regular Filter Changes
- Replace or clean HVAC filters every 1-3 months
- Dirty filters reduce efficiency by 5-15%
- Consider high-efficiency pleated filters for better air quality
- Mark calendar reminders for filter replacements

### Annual Professional Maintenance
- Schedule professional HVAC inspection annually
- Clean coils, check refrigerant levels, and test system efficiency
- Well-maintained systems use 15-20% less energy
- Address minor issues before they become costly repairs

### Duct Sealing and Insulation
- Seal air leaks in ductwork with mastic sealant or metal tape
- Insulate ducts in unconditioned spaces (attics, crawl spaces, garages)
- Leaky ducts can waste 20-30% of heating and cooling energy
- Consider professional duct testing and sealing

## Smart HVAC Strategies

### Time-of-Use Optimization
- Pre-cool or pre-heat home during off-peak electricity hours
- Use thermal mass of the building to maintain comfort during peak hours
- Reduce HVAC use during peak pricing periods (typically 4-8 PM)
- Program thermostat to adjust temperatures based on electricity rates

### Integration with Weather Forecasts
- Adjust thermostat settings based on upcoming weather
- Open windows for natural ventilation during mild weather
- Pre-cool before heat waves to reduce peak demand
- Use night setback more aggressively on mild nights

### Humidity Control
- Maintain 30-50% relative humidity for optimal comfort
- Lower humidity allows higher thermostat settings in summer
- Use dehumidifiers in humid climates to reduce cooling load
- Ensure proper drainage from HVAC condensate

## Advanced Efficiency Measures

### Heat Pump Optimization
- Heat pumps are 2-3x more efficient than traditional systems
- Use auxiliary heat only when necessary (below 35Â°F/2Â°C)
- Maintain outdoor units clear of debris and snow
- Consider dual-fuel systems for extreme climates

### Variable Speed Systems
- Variable speed compressors adjust output to match demand
- Run more efficiently at partial loads
- Provide better humidity control and air filtration
- Can reduce energy use by 20-40% compared to single-speed systems

### Thermal Envelope Improvements
- Seal air leaks around windows, doors, and penetrations
- Add insulation to attics, walls, and crawl spaces
- Install energy-efficient windows with low-E coatings
- Use weatherstripping and door sweeps to reduce drafts

## Seasonal Strategies

### Summer Cooling Tips
- Use window coverings to block direct sunlight
- Cook outdoors or use microwave to reduce indoor heat gain
- Run heat-generating appliances in the evening
- Plant shade trees on south and west sides of home
- Use exhaust fans when cooking or showering

### Winter Heating Tips
- Open curtains on south-facing windows during the day
- Close curtains at night to retain heat
- Use space heaters for spot heating in occupied rooms
- Reverse ceiling fan direction to push warm air down
- Keep outdoor units clear of snow and ice

### Shoulder Season Strategies
- Use natural ventilation instead of HVAC when possible
- Open windows in morning and evening for free cooling
- Use whole-house fans to purge hot air in the evening
- Take advantage of temperature swings to minimize HVAC use

## Cost-Benefit Analysis

### Energy Savings Potential
- Programmable thermostat: $180/year savings
- Regular maintenance: 15% reduction in HVAC costs
- Duct sealing: $200-400/year savings
- Heat pump upgrade: 30-50% reduction in heating costs
- Insulation improvements: 10-30% total energy savings

### Return on Investment
- Smart thermostat: 1-2 year payback
- Professional duct sealing: 3-5 year payback
- Heat pump installation: 7-12 year payback
- Insulation upgrades: 3-8 year payback
- Window replacements: 10-20 year payback
</file_content>

<file_content path="data/documents/tip_renewable_energy_integration.txt">
Renewable Energy Integration

1.  Solar Photovoltaic (PV) Systems:
    *   **Grid-Tied Systems:** Connected to the utility grid, allowing you to draw power when solar production is low and send excess power back to the grid (net metering).
    *   **Off-Grid Systems:** Independent of the utility grid, requiring battery storage to supply power during non-daylight hours.
    *   **Hybrid Systems:** Combine grid-tied functionality with battery storage for backup power and optimized self-consumption.
    *   **Optimization:** Orient panels for maximum sun exposure, keep them clean, and monitor performance.

2.  Battery Energy Storage Systems (BESS):
    *   **Purpose:** Store excess renewable energy for later use, provide backup power, and enable time-of-use arbitrage.
    *   **Integration with Solar:** Charge batteries with solar during the day, discharge at night or during peak demand.
    *   **Types:** Lithium-ion is most common for residential, but other chemistries exist.

3.  Wind Energy:
    *   **Small Wind Turbines:** Suitable for properties with consistent wind resources and sufficient space.
    *   **Integration:** Can be integrated with solar and battery storage for a more resilient hybrid system.

4.  Geothermal Energy:
    *   **Geothermal Heat Pumps:** Use the stable temperature of the earth to provide highly efficient heating and cooling.
    *   **Integration:** Can significantly reduce HVAC energy consumption, complementing other renewable sources.

5.  Hydroelectric (Micro-hydro):
    *   **Applicability:** Limited to properties with access to a flowing water source with sufficient head and flow.
    *   **Benefits:** Provides consistent, baseload renewable power.

6.  Smart Grid Integration:
    *   **Demand Response:** Participate in utility programs to reduce energy consumption during peak demand periods, often by leveraging smart devices and energy storage.
    *   **Virtual Power Plants (VPPs):** Aggregation of distributed energy resources (like solar and batteries) to provide grid services.

7.  Challenges and Considerations:
    *   **Intermittency:** Solar and wind power are variable; storage and grid integration are crucial.
    *   **Cost:** Initial investment can be high, but incentives and long-term savings can offset this.
    *   **Permitting and Regulations:** Local regulations can impact installation and grid connection.
    *   **Maintenance:** Regular maintenance is required for optimal performance and longevity.
</file_content>

<file_content path="data/documents/tip_seasonal_energy_management.txt">
Seasonal Energy Management Strategies

1.  Summer Cooling Optimization:
    *   Set thermostat higher when away (e.g., 78-80Â°F).
    *   Use ceiling fans to create a wind-chill effect, allowing higher thermostat settings.
    *   Close blinds and curtains during the day to block solar heat gain.
    *   Ensure HVAC system is regularly maintained (clean filters, professional tune-ups).
    *   Consider smart thermostats for automated scheduling and remote control.

2.  Winter Heating Optimization:
    *   Set thermostat lower when away or asleep (e.g., 60-65Â°F).
    *   Seal drafts around windows and doors with weatherstripping and caulk.
    *   Open curtains on sunny days to allow passive solar heating, close them at night to retain heat.
    *   Ensure furnace is regularly maintained (clean filters, professional tune-ups).
    *   Use programmable thermostats to match heating to occupancy.

3.  Shoulder Seasons (Spring/Fall) Strategies:
    *   Utilize natural ventilation: open windows at night to cool the home, close them during the day.
    *   Minimize reliance on HVAC by dressing appropriately for the indoor temperature.
    *   Perform seasonal maintenance on both heating and cooling systems.

4.  Appliance Usage:
    *   Run dishwashers and washing machines during off-peak hours, especially in summer to avoid adding heat to the home.
    *   Use outdoor clotheslines when weather permits.

5.  Landscaping:
    *   Plant deciduous trees on the south and west sides of the house to provide summer shade and allow winter sun.
    *   Use evergreen shrubs as windbreaks in winter.
</file_content>

<file_content path="data/documents/tip_smart_home_automation.txt">
# Smart Home Automation for Energy Efficiency

## Smart Thermostats and Climate Control

### Advanced Features
- Learn your schedule and preferences automatically
- Geofencing: adjust temperature when you leave/return home
- Remote control via smartphone apps
- Integration with voice assistants (Alexa, Google, Siri)
- Energy usage reports and recommendations

### Popular Smart Thermostats
- Nest Learning Thermostat: Auto-learning, energy history, remote sensors
- Ecobee SmartThermostat: Room sensors, voice control, occupancy detection
- Honeywell Home T9: Smart room sensors, geofencing, scheduling
- Typical savings: 10-23% on heating, 15% on cooling costs

### Optimization Strategies
- Use occupancy sensors to adjust temperature in real-time
- Integrate with weather forecasts for predictive adjustments
- Set different schedules for weekdays and weekends
- Enable eco-mode when away for extended periods
- Use room sensors to balance temperature across zones

## Smart Lighting Systems

### LED Smart Bulbs
- 75-80% more efficient than incandescent bulbs
- Last 15-25 times longer than traditional bulbs
- Dimmable and color-changing capabilities
- Schedulable on/off times and automation rules
- Motion sensors for automatic activation

### Smart Switches and Dimmers
- Control entire circuits without replacing bulbs
- Occupancy and vacancy sensors
- Dimming reduces energy use and extends bulb life
- Timer functions for automatic shutoff
- Integration with whole-home automation systems

### Lighting Automation Strategies
- Use motion sensors in bathrooms, closets, and hallways
- Schedule lights to turn off automatically when leaving
- Dim lights during evening hours to reduce consumption
- Use natural light sensors to adjust artificial lighting
- Create scenes for different activities with optimal lighting levels

## Smart Power Management

### Smart Plugs and Outlets
- Monitor energy usage of individual devices
- Schedule on/off times for appliances
- Remote control from smartphone
- Eliminate vampire power draw by cutting power completely
- Typical savings: $50-100/year per household

### Smart Power Strips
- Master-controlled outlets for entertainment centers
- Timer-based shutoff for device groups
- Individual outlet control and monitoring
- Surge protection combined with energy management
- USB charging ports with smart features

### Vampire Power Elimination
- Devices consume 5-10% of residential electricity when "off"
- Average home has 20-40 devices drawing standby power
- Smart plugs can eliminate this waste automatically
- Common culprits: TVs, cable boxes, game consoles, chargers
- Annual savings potential: $100-200 per household

## Smart Appliance Integration

### Connected Major Appliances
- Smart refrigerators: energy monitoring, temperature optimization
- Smart washers/dryers: delay start for off-peak hours
- Smart dishwashers: eco modes and cycle optimization
- Smart ovens: remote preheating, precise temperature control
- Energy Star certified smart appliances use 10-50% less energy

### Appliance Automation
- Run dishwasher and laundry during off-peak hours
- Receive notifications when cycles complete
- Monitor energy consumption in real-time
- Optimize settings based on load size and type
- Integration with home energy management systems

## Home Energy Management Systems (HEMS)

### Whole-Home Energy Monitoring
- Track electricity usage in real-time
- Identify energy hogs and inefficient devices
- Set energy budgets and receive alerts
- Historical data analysis and trend identification
- Integration with solar, battery, and EV chargers

### Popular HEMS Platforms
- Sense Home Energy Monitor: circuit-level detection, solar integration
- Emporia Vue: 16-circuit monitoring, solar and EV tracking
- Neurio Home Energy Monitor: real-time monitoring, smart home integration
- Typical savings: 5-15% through awareness and optimization

### Advanced HEMS Features
- Demand response program participation
- Automatic load shedding during peak pricing
- Battery storage optimization
- EV charging scheduling
- Integration with utility time-of-use rates

## Smart Window Treatments

### Automated Shades and Blinds
- Schedule opening/closing based on sun position
- Integration with temperature sensors
- Reduce solar heat gain in summer by 45-75%
- Reduce heat loss through windows by 10-25% in winter
- Voice and app control for convenience

### Smart Glass
- Electrochromic windows that tint automatically
- Reduce cooling costs by up to 20%
- Eliminate need for blinds and shades
- Maximize natural light while controlling heat
- Higher initial cost but excellent long-term ROI

## Voice Assistants and AI Integration

### Energy Management via Voice Control
- "Alexa, set thermostat to eco mode"
- "Hey Google, turn off all lights in 10 minutes"
- "Siri, what's my energy usage today?"
- Create custom routines for energy optimization
- Hands-free control improves compliance with energy plans

### AI-Powered Optimization
- Machine learning algorithms predict usage patterns
- Automatic adjustments based on occupancy and preferences
- Weather-based proactive climate control
- Anomaly detection for equipment failures
- Continuous optimization without user intervention

## Smart Water Heating

### Connected Water Heaters
- Remote temperature control and scheduling
- Vacation mode for extended periods away
- Leak detection and alerts
- Energy usage monitoring
- Heat pump water heaters with smart features

### Optimization Strategies
- Lower temperature to 120Â°F when possible
- Schedule heating during off-peak hours
- Use vacation mode when away
- Integrate with solar production data
- Monitor for efficiency degradation

## Home Automation Platforms

### Popular Ecosystems
- Apple HomeKit: Privacy-focused, secure, iOS-centric
- Google Home: AI-powered, voice control, wide compatibility
- Amazon Alexa: Extensive device support, skills marketplace
- Samsung SmartThings: Multi-protocol support, local processing
- Home Assistant: Open-source, highly customizable, local control

### Integration Best Practices
- Choose devices compatible with your preferred platform
- Use Z-Wave or Zigbee for reliable, low-power communication
- Implement local control where possible for reliability
- Create automation rules for maximum energy savings
- Regularly update firmware for security and features

## ROI and Implementation Strategy

### Cost-Benefit Analysis
- Smart thermostat: $200-300, 1-2 year payback
- Smart lighting: $10-50 per bulb, 2-3 year payback
- Smart plugs: $15-30 each, 1-2 year payback
- Energy monitor: $150-300, 2-4 year payback
- Whole-home automation: $1000-5000, 3-7 year payback

### Implementation Roadmap
1. Start with smart thermostat (highest impact)
2. Add smart lighting in high-use areas
3. Deploy smart plugs for major appliances
4. Install whole-home energy monitor
5. Expand to advanced automation and integration
6. Continuously refine rules based on data and habits
</file_content>


================================================================================
END OF FILE: energy-advisor/my_submission/master_context.md
================================================================================



================================================================================
